-- Smile B | Jailbreak - Full Centralized & Redesigned LocalScript
-- Paste into StarterPlayerScripts (LocalScript)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- ===== configuration =====
local DEFAULT_KILL_RANGE = 1000
local KILLAURA_TICK = 0.22
local GIVEITEM_ATTEMPT_DELAY = 0.18
local GIVEITEM_MAX_ATTEMPTS = 400
local DAMAGE_PRIORITY_WINDOW = 3
local LOG_CAP = 50
local ESP_UPDATE_INTERVAL = 0.1
local ESP_FULL_RELOAD_INTERVAL = 2.5
local PISTOL_CHECK_INTERVAL = 0.5
local UI_FADE_TIME = 0.25

-- extra timing used later (were referenced but not defined in base)
local EQUIP_WAIT_TIME = 0.12
local FIRE_DELAY = 0.06

-- UI corner radius
local UI_CORNER_RADIUS = UDim.new(0, 12)

-- ===== state =====
local state = {
    keyBypass = false,
    esp = false,
    killAura = false,
    silentAim = false,
    killRange = DEFAULT_KILL_RANGE,
    hasPistol = false,
    tryingToGetPistol = false,
    killLoopId = 0,
    currentTarget = nil
}
local logs = {}
local lastHealth = nil
local lastDamageTime = 0
local lastDamagePosition = nil

-- ===== cached modules (if any) =====
local RayCastModule
pcall(function()
    RayCastModule = ReplicatedStorage:FindFirstChild("Module") and require(ReplicatedStorage.Module.RayCast)
end)
local oldRayIgnore = RayCastModule and RayCastModule.RayIgnoreNonCollideWithIgnoreList

-- helper to add UICorner uniformly
local function addCorner(inst)
    if not inst then return end
    local c = Instance.new("UICorner")
    c.CornerRadius = UI_CORNER_RADIUS
    c.Parent = inst
    return c
end

-- ===== GUI =====
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SmileB_JailbreakUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = PlayerGui

-- Always visible status strip (wider + rounded)
local alwaysVisibleStatus = Instance.new("TextLabel")
alwaysVisibleStatus.Name = "StatusStrip"
alwaysVisibleStatus.Size = UDim2.new(0, 460, 0, 30) -- wider to fit text
alwaysVisibleStatus.Position = UDim2.new(1, -470, 0, 10)
alwaysVisibleStatus.AnchorPoint = Vector2.new(0, 0)
alwaysVisibleStatus.BackgroundTransparency = 0.18
alwaysVisibleStatus.BackgroundColor3 = Color3.fromRGB(40,40,40)
alwaysVisibleStatus.BorderSizePixel = 0
alwaysVisibleStatus.Font = Enum.Font.SourceSans
alwaysVisibleStatus.TextSize = 13
alwaysVisibleStatus.TextXAlignment = Enum.TextXAlignment.Left
alwaysVisibleStatus.TextColor3 = Color3.fromRGB(230,230,230)
alwaysVisibleStatus.Text = "Pistol: No  KillAura: OFF  SilentAim: OFF  ESP: OFF  KeyBypass: OFF"
alwaysVisibleStatus.Parent = screenGui
addCorner(alwaysVisibleStatus)

-- Main frame
local main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0, 650, 0, 340)
main.Position = UDim2.new(0.5, -325, 0.5, -170)
main.BackgroundColor3 = Color3.fromRGB(30,30,30)
main.BorderSizePixel = 0
main.Active = true
main.Draggable = true
main.Parent = screenGui
addCorner(main)

-- Header
local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2.new(1,0,0,44)
header.BackgroundColor3 = Color3.fromRGB(28,28,30)
header.BorderSizePixel = 0
header.Parent = main
addCorner(header)

local title = Instance.new("TextLabel", header)
title.Name = "Title"
title.Position = UDim2.new(0,12,0,0)
title.Size = UDim2.new(1,-180,1,0)
title.BackgroundTransparency = 1
title.Text = "Jailbreak | Smile B"
title.Font = Enum.Font.SourceSansBold
title.TextSize = 16
title.TextXAlignment = Enum.TextXAlignment.Left
title.TextColor3 = Color3.fromRGB(200,200,255)

-- Minimize button
local btnMin = Instance.new("TextButton", header)
btnMin.Name = "BtnMin"
btnMin.Size = UDim2.new(0,28,0,28)
btnMin.Position = UDim2.new(1,-110,0,8)
btnMin.Text = "-"
btnMin.Font = Enum.Font.SourceSansBold
btnMin.BackgroundColor3 = Color3.fromRGB(36,36,40)
btnMin.TextColor3 = Color3.fromRGB(255,223,120)
btnMin.BorderSizePixel = 0
addCorner(btnMin)

-- Close button
local btnClose = Instance.new("TextButton", header)
btnClose.Name = "BtnClose"
btnClose.Size = UDim2.new(0,28,0,28)
btnClose.Position = UDim2.new(1,-70,0,8)
btnClose.Text = "x"
btnClose.Font = Enum.Font.SourceSansBold
btnClose.BackgroundColor3 = Color3.fromRGB(36,36,40)
btnClose.TextColor3 = Color3.fromRGB(255,120,120)
btnClose.BorderSizePixel = 0
addCorner(btnClose)

-- Confirmation frame for close
local confirmationFrame = Instance.new("Frame")
confirmationFrame.Name = "Confirmation"
confirmationFrame.Size = UDim2.new(0, 320,0,160)
confirmationFrame.Position = UDim2.new(0.5,-160,0.5,-80)
confirmationFrame.BackgroundColor3 = Color3.fromRGB(30,30,32)
confirmationFrame.BorderSizePixel = 0
confirmationFrame.Visible = false
confirmationFrame.Parent = screenGui
addCorner(confirmationFrame)

local confTitle = Instance.new("TextLabel", confirmationFrame)
confTitle.Size = UDim2.new(1,0,0,44)
confTitle.BackgroundTransparency = 1
confTitle.Text = "Are you sure?"
confTitle.Font = Enum.Font.SourceSansBold
confTitle.TextSize = 18
confTitle.TextColor3 = Color3.fromRGB(255,255,255)

local confText = Instance.new("TextLabel", confirmationFrame)
confText.Size = UDim2.new(1,0,0,66)
confText.Position = UDim2.new(0,0,0,44)
confText.BackgroundTransparency = 1
confText.Text = "Closing will disable all features."
confText.Font = Enum.Font.SourceSans
confText.TextSize = 14
confText.TextColor3 = Color3.fromRGB(220,220,220)
confText.TextWrapped = true

local btnYes = Instance.new("TextButton", confirmationFrame)
btnYes.Size = UDim2.new(0.4,0,0,32)
btnYes.Position = UDim2.new(0.06,0,1,-44)
btnYes.Text = "Yes"
btnYes.Font = Enum.Font.SourceSansBold
btnYes.BackgroundColor3 = Color3.fromRGB(255,80,80)
btnYes.TextColor3 = Color3.fromRGB(255,255,255)
btnYes.BorderSizePixel = 0
addCorner(btnYes)

local btnNo = Instance.new("TextButton", confirmationFrame)
btnNo.Size = UDim2.new(0.4,0,0,32)
btnNo.Position = UDim2.new(0.54,0,1,-44)
btnNo.Text = "No"
btnNo.Font = Enum.Font.SourceSansBold
btnNo.BackgroundColor3 = Color3.fromRGB(80,80,80)
btnNo.TextColor3 = Color3.fromRGB(255,255,255)
btnNo.BorderSizePixel = 0
addCorner(btnNo)

-- left and right panels
local left = Instance.new("Frame", main)
left.Name = "LeftPanel"
left.Size = UDim2.new(0.45, -12, 1, -64)
left.Position = UDim2.new(0, 8, 0, 52)
left.BackgroundTransparency = 1
addCorner(left)

local leftLayout = Instance.new("UIListLayout", left)
leftLayout.SortOrder = Enum.SortOrder.LayoutOrder
leftLayout.Padding = UDim.new(0,8)

local right = Instance.new("Frame", main)
right.Name = "RightPanel"
right.Size = UDim2.new(0.55, -12, 1, -64)
right.Position = UDim2.new(0.45, 6, 0, 52)
right.BackgroundColor3 = Color3.fromRGB(14,14,16)
right.BorderSizePixel = 0
right.ClipsDescendants = true
addCorner(right)

-- logs title and clear button
local logsTitle = Instance.new("TextLabel", right)
logsTitle.Name = "LogsTitle"
logsTitle.Size = UDim2.new(1,0,0,26)
logsTitle.Position = UDim2.new(0,0,0,6)
logsTitle.BackgroundTransparency = 1
logsTitle.Text = "Logs (last "..LOG_CAP..")"
logsTitle.Font = Enum.Font.SourceSansBold
logsTitle.TextSize = 14
logsTitle.TextColor3 = Color3.fromRGB(220,220,220)

local clearBtn = Instance.new("TextButton", right)
clearBtn.Name = "ClearLogs"
clearBtn.Size = UDim2.new(0,68,0,28)
clearBtn.Position = UDim2.new(1,-76,0,6)
clearBtn.Text = "Clear"
clearBtn.Font = Enum.Font.SourceSans
clearBtn.TextSize = 12
clearBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
clearBtn.TextColor3 = Color3.fromRGB(240,240,240)
clearBtn.BorderSizePixel = 0
addCorner(clearBtn)

-- logs scrolling frame
local logsScroll = Instance.new("ScrollingFrame", right)
logsScroll.Name = "LogsScroll"
logsScroll.Size = UDim2.new(1,-12,1,-54)
logsScroll.Position = UDim2.new(0,6,0,36)
logsScroll.BackgroundTransparency = 1
logsScroll.ScrollBarThickness = 8
addCorner(logsScroll)

local logsList = Instance.new("Frame", logsScroll)
logsList.Name = "LogsList"
logsList.Size = UDim2.new(1,0,1,0)
logsList.BackgroundTransparency = 1
local logsLayout2 = Instance.new("UIListLayout", logsList)
logsLayout2.SortOrder = Enum.SortOrder.LayoutOrder
logsLayout2.Padding = UDim.new(0,4)

-- fade helpers (unchanged, kept for completeness)
local function fadeRecursive(parent, transparency, time)
    local tweens = {}
    local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    if parent:IsA("Frame") or parent:IsA("ScrollingFrame") then
        table.insert(tweens, TweenService:Create(parent, tweenInfo, {BackgroundTransparency = transparency}))
    elseif parent:IsA("TextLabel") or parent:IsA("TextButton") or parent:IsA("TextBox") then
        table.insert(tweens, TweenService:Create(parent, tweenInfo, {TextTransparency = transparency, BackgroundTransparency = transparency}))
    elseif parent:IsA("ImageLabel") or parent:IsA("ImageButton") then
        table.insert(tweens, TweenService:Create(parent, tweenInfo, {ImageTransparency = transparency, BackgroundTransparency = transparency}))
    end
    for _, child in ipairs(parent:GetChildren()) do
        local childTweens = fadeRecursive(child, transparency, time)
        for _, t in ipairs(childTweens) do table.insert(tweens, t) end
    end
    return tweens
end

local function fadeIn(frame, time)
    fadeRecursive(frame, 1, 0)
    frame.Visible = true
    fadeRecursive(frame, 0, time)
end

local function fadeOut(frame, time)
    local tweens = fadeRecursive(frame, 1, time)
    for _, t in ipairs(tweens) do t.Completed:Wait() end
    frame.Visible = false
end

-- logging
local function pushLog(msg)
    local entry = ("[%s] %s"):format(os.date("%H:%M:%S"), tostring(msg))
    table.insert(logs, entry)
    if #logs > LOG_CAP then table.remove(logs, 1) end
    print("[SmileB] " .. entry)
    if logsList and logsScroll then
        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.new(1, -8, 0, 18)
        lbl.BackgroundTransparency = 1
        lbl.Text = entry
        lbl.Font = Enum.Font.SourceSans
        lbl.TextSize = 14
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        lbl.TextColor3 = Color3.fromRGB(220,220,220)
        lbl.Parent = logsList
        task.defer(function()
            local layout = logsList:FindFirstChildOfClass("UIListLayout")
            if layout then
                logsScroll.CanvasSize = UDim2.new(0,0,0,layout.AbsoluteContentSize.Y + 8)
                logsScroll.CanvasPosition = Vector2.new(0, layout.AbsoluteContentSize.Y + 8)
            end
        end)
    end
end

clearBtn.MouseButton1Click:Connect(function()
    for _,c in ipairs(logsList:GetChildren()) do if c:IsA("TextLabel") then c:Destroy() end end
    logs = {}
    pushLog("Logs cleared")
end)

-- ===== helper row/controls creators (add corners everywhere) =====
local function newRow(parent, height)
    height = height or 34
    local f = Instance.new("Frame")
    f.Size = UDim2.new(1,0,0,height)
    f.BackgroundTransparency = 1
    f.Parent = parent
    return f
end

local function createToggle(parent, labelText, default, callback)
    local row = newRow(parent,34)
    local lbl = Instance.new("TextLabel", row)
    lbl.Size = UDim2.new(0.6,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = labelText
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 14
    lbl.TextColor3 = Color3.fromRGB(230,230,230)
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local btn = Instance.new("TextButton", row)
    btn.Size = UDim2.new(0,68,0,28)
    btn.Position = UDim2.new(1,-76,0,3)
    btn.Text = default and "ON" or "OFF"
    btn.Font = Enum.Font.SourceSansBold
    btn.TextSize = 13
    btn.BorderSizePixel = 0
    btn.BackgroundColor3 = default and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    addCorner(btn)

    local st = default
    btn.MouseButton1Click:Connect(function()
        st = not st
        btn.Text = st and "ON" or "OFF"
        btn.BackgroundColor3 = st and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
        callback(st)
    end)
    return row, btn
end

local function createSlider(parent, name, min, max, default, callback)
    local row = newRow(parent,40)
    local lbl = Instance.new("TextLabel", row)
    lbl.Size = UDim2.new(0.58,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = name .. ": " .. tostring(default)
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 14
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local slider = Instance.new("Frame", row)
    slider.Size = UDim2.new(0.38,0,0.45,0)
    slider.Position = UDim2.new(0.6,0,0.275,0)
    slider.BackgroundColor3 = Color3.fromRGB(60,60,60)
    slider.BorderSizePixel = 0
    slider.ClipsDescendants = true
    addCorner(slider)

    local fill = Instance.new("Frame", slider)
    fill.Size = UDim2.new((default-min)/(max-min),0,1,0)
    fill.BackgroundColor3 = Color3.fromRGB(128,0,128)
    fill.BorderSizePixel = 0
    addCorner(fill)

    local dragging = false
    local conn
    local function updateFromPos(pos)
        local x = math.clamp(pos.X - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X)
        local pct = x / slider.AbsoluteSize.X
        local value = math.floor(min + pct * (max - min))
        fill.Size = UDim2.new(pct,0,1,0)
        lbl.Text = name .. ": " .. tostring(value)
        callback(value)
    end
    slider.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            main.Draggable = false
            conn = UserInputService.InputChanged:Connect(function(move)
                if dragging and (move.UserInputType == Enum.UserInputType.MouseMovement or move.UserInputType == Enum.UserInputType.Touch) then
                    updateFromPos(move.Position)
                end
            end)
        end
    end)
    slider.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
            main.Draggable = true
            if conn then conn:Disconnect(); conn = nil end
        end
    end)
    return row, slider, fill, lbl
end

-- ===== left controls content =====
-- Keycard toggle
createToggle(left, "Keycard Bypass", false, function(v)
    state.keyBypass = v
    local ok, plrUtils = pcall(function() return ReplicatedStorage:FindFirstChild("Game") and ReplicatedStorage.Game:FindFirstChild("PlayerUtils") end)
    if ok and plrUtils then
        if v then
            if not rawget(_G, "SmileB_original_hasKey") then pcall(function() rawset(_G, "SmileB_original_hasKey", require(plrUtils).hasKey) end) end
            pcall(function() require(plrUtils).hasKey = function() return true end end)
            pushLog("Keycard bypass enabled")
        else
            pcall(function() require(plrUtils).hasKey = rawget(_G, "SmileB_original_hasKey") or require(plrUtils).hasKey end)
            pushLog("Keycard bypass disabled")
        end
    else
        pushLog("Keycard bypass: PlayerUtils not found")
    end
    alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s")
        :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
end)

-- KillAura toggle
createToggle(left, "KillAura (1000 Recommended)", false, function(v)
    state.killAura = v
    pushLog("KillAura toggled: "..tostring(v))
    if v and LocalPlayer.Character then
        spawn(function() runKillAura(LocalPlayer.Character) end)
    else
        state.killLoopId = state.killLoopId + 1
    end
    alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s")
        :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
end)

-- SilentAim toggle
createToggle(left, "Silent Aim", false, function(v)
    state.silentAim = v
    pushLog("Silent Aim toggled: "..tostring(v))
    updateSilentAimOverride(v)
    if v then ensurePistol() end
    alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s")
        :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
end)

-- Range slider
local _,_,_, killLabel = createSlider(left, "Range (KillAura/Silent)", 100, 5000, DEFAULT_KILL_RANGE, function(v)
    state.killRange = v
    killLabel.Text = "Range (KillAura/Silent): "..tostring(v)
end)
state.killRange = DEFAULT_KILL_RANGE

-- ESP toggle
createToggle(left, "ESP", false, function(v)
    state.esp = v
    pushLog("ESP toggled: "..tostring(v))
    if not v then
        for p,h in pairs(highlightMap) do pcall(function() h:Destroy() end) highlightMap[p] = nil end
        for p,b in pairs(nameTagMap) do pcall(function() b:Destroy() end) nameTagMap[p] = nil end
    else
        for _,pl in pairs(Players:GetPlayers()) do spawn(function() pcall(function() setupESPForPlayer(pl) end) end) end
    end
    alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s")
        :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
end)

-- Grab Items button
local grabRow = newRow(left, 36)
local grabLbl = Instance.new("TextLabel", grabRow)
grabLbl.Size = UDim2.new(0.6,0,1,0)
grabLbl.BackgroundTransparency = 1
grabLbl.Text = "Grab Items"
grabLbl.Font = Enum.Font.SourceSans
grabLbl.TextSize = 14
grabLbl.TextColor3 = Color3.fromRGB(230,230,230)
grabLbl.TextXAlignment = Enum.TextXAlignment.Left

local grabBtn = Instance.new("TextButton", grabRow)
grabBtn.Size = UDim2.new(0,68,0,28)
grabBtn.Position = UDim2.new(1,-76,0,4)
grabBtn.Text = "Grab"
grabBtn.Font = Enum.Font.SourceSansBold
grabBtn.TextSize = 13
grabBtn.BorderSizePixel = 0
grabBtn.BackgroundColor3 = Color3.fromRGB(70,70,70)
grabBtn.TextColor3 = Color3.fromRGB(255,255,255)
addCorner(grabBtn)

-- floating minimized hamburger button
local minimizedBtn = Instance.new("TextButton")
minimizedBtn.Name = "MinimizedBtn"
minimizedBtn.Parent = screenGui
minimizedBtn.Size = UDim2.new(0, 48, 0, 48)
minimizedBtn.Position = UDim2.new(0, 10, 0, 100)
minimizedBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
minimizedBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizedBtn.Text = "â‰¡"
minimizedBtn.TextScaled = true
minimizedBtn.Font = Enum.Font.SourceSansBold
minimizedBtn.Visible = false
minimizedBtn.Active = true
minimizedBtn.Draggable = true
addCorner(minimizedBtn)

-- ===== fade helpers for visibility used earlier (kept) =====

-- ===== ESP (kept) =====
local highlightMap = {}
local nameTagMap = {}

local function teamColorForPlayer(p)
    if not p then return Color3.fromRGB(200,200,200) end
    local t = tostring(p.Team)
    if t == "Police" then return Color3.fromRGB(0,122,255) end
    if t == "Criminal" then return Color3.fromRGB(255,40,40) end
    return p.TeamColor and p.TeamColor.Color or Color3.fromRGB(200,200,200)
end

local function makeNameTagFor(p)
    if not p.Character then return nil end
    local head = p.Character:FindFirstChild("Head")
    if not head then return nil end
    local bg = Instance.new("BillboardGui")
    bg.Name = "SmileB_NameTag"
    bg.Size = UDim2.new(0,160,0,28)
    bg.StudsOffset = Vector3.new(0,2.2,0)
    bg.AlwaysOnTop = true
    bg.Adornee = head
    local txt = Instance.new("TextLabel", bg)
    txt.Size = UDim2.new(1,0,1,0)
    txt.BackgroundTransparency = 1
    txt.Font = Enum.Font.SourceSansBold
    txt.TextScaled = true
    txt.Text = p.Name
    txt.TextColor3 = teamColorForPlayer(p)
    txt.TextStrokeTransparency = 0
    return bg, txt
end

function setupESPForPlayer(p)
    if not state.esp or not p or not p.Character then return end
    pcall(function()
        if highlightMap[p] and highlightMap[p].Parent then highlightMap[p]:Destroy() end
        local existing = p.Character:FindFirstChild("SmileB_Highlight")
        if existing then existing:Destroy() end
        local hl = Instance.new("Highlight")
        hl.Name = "SmileB_Highlight"
        hl.Adornee = p.Character
        hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        hl.Parent = p.Character
        highlightMap[p] = hl
        hl.FillColor = teamColorForPlayer(p)
    end)
    pcall(function()
        if nameTagMap[p] and nameTagMap[p].Parent then nameTagMap[p]:Destroy() end
        local bg, txt = makeNameTagFor(p)
        if bg then bg.Parent = p.Character; nameTagMap[p] = bg end
    end)
end

function cleanupESPForPlayer(p)
    if highlightMap[p] then pcall(function() highlightMap[p]:Destroy() end) highlightMap[p] = nil end
    if nameTagMap[p] then pcall(function() nameTagMap[p]:Destroy() end) nameTagMap[p] = nil end
end

function updateESPColorFor(p)
    if not state.esp then return end
    if highlightMap[p] and highlightMap[p].Parent then highlightMap[p].FillColor = teamColorForPlayer(p) end
    if nameTagMap[p] and nameTagMap[p].Parent then
        local lbl = nameTagMap[p]:FindFirstChildWhichIsA("TextLabel")
        if lbl then lbl.TextColor3 = teamColorForPlayer(p) end
    end
end

Players.PlayerAdded:Connect(function(pl)
    pl.CharacterAdded:Connect(function() if state.esp then setupESPForPlayer(pl) end end)
    pl:GetPropertyChangedSignal("TeamColor"):Connect(function() updateESPColorFor(pl) end)
end)
Players.PlayerRemoving:Connect(function(pl) cleanupESPForPlayer(pl) end)
for _,pl in ipairs(Players:GetPlayers()) do
    pl.CharacterAdded:Connect(function() if state.esp then setupESPForPlayer(pl) end end)
    pl:GetPropertyChangedSignal("TeamColor"):Connect(function() updateESPColorFor(pl) end)
end

-- realtime update loop for ESP
spawn(function()
    while main and main.Parent do
        if state.esp then
            local myChar = LocalPlayer.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            for _,pl in ipairs(Players:GetPlayers()) do
                if pl ~= LocalPlayer then
                    if pl.Character then
                        if not highlightMap[pl] then pcall(function() setupESPForPlayer(pl) end) end
                        pcall(function() updateESPColorFor(pl) end)
                        if nameTagMap[pl] and nameTagMap[pl].Parent then
                            local theirRoot = pl.Character:FindFirstChild("HumanoidRootPart")
                            local dist = myRoot and theirRoot and math.floor((myRoot.Position - theirRoot.Position).Magnitude) or "?"
                            local lbl = nameTagMap[pl]:FindFirstChildWhichIsA("TextLabel")
                            if lbl then lbl.Text = pl.Name .. " (" .. tostring(dist) .. " studs)" end
                        end
                    else
                        pcall(function() cleanupESPForPlayer(pl) end)
                    end
                end
            end
        end
        task.wait(ESP_UPDATE_INTERVAL)
    end
end)

-- periodic full reload for ESP
spawn(function()
    while main and main.Parent do
        if state.esp then
            for _,pl in ipairs(Players:GetPlayers()) do
                pcall(function()
                    cleanupESPForPlayer(pl)
                    setupESPForPlayer(pl)
                end)
            end
        end
        task.wait(ESP_FULL_RELOAD_INTERVAL)
    end
end)

-- ===== pistol acquisition / grabbed items =====
local function tryClickGiversOnce()
    if not Workspace:FindFirstChild("Givers") then return false end
    for _,g in ipairs(Workspace.Givers:GetChildren()) do
        if not g or not g.Parent then continue end
        local cd = g:FindFirstChildWhichIsA("ClickDetector")
        if cd then
            pcall(function() fireclickdetector(cd) end)
            task.wait(0.04)
            if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then return true end
        end
    end
    return false
end

local function tryPickupDroppedOnce()
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local found = false
    for _,obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Parent and obj.Parent:IsA("Model") then
            local name = tostring(obj.Name):lower()
            if string.find(name, "pistol") or string.find(name, "gun") or string.find(name, "rifle") or string.find(name, "shotgun") or string.find(name, "ammo") or string.find(name, "cash") or string.find(name, "money") or string.find(name, "bag") or string.find(name, "drop") then
                pcall(function()
                    firetouchinterest(obj, hrp, 0)
                    task.wait(0.03)
                    firetouchinterest(obj, hrp, 1)
                    task.wait(0.05)
                end)
                found = true
                if LocalPlayer:FindFirstChild("Folder") and #LocalPlayer.Folder:GetChildren() > 0 then
                    return true
                end
            end
        end
    end
    return found
end

local function ensurePistol()
    if state.tryingToGetPistol or state.hasPistol then return end
    state.tryingToGetPistol = true
    pushLog("Pistol acquisition: scanning Givers...")
    spawn(function()
        local attempts = 0
        while not state.hasPistol and attempts < GIVEITEM_MAX_ATTEMPTS do
            pcall(tryClickGiversOnce)
            pcall(tryPickupDroppedOnce)
            attempts = attempts + 1
            if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then
                state.hasPistol = true
                pushLog("Pistol obtained after "..tostring(attempts).." attempts")
                break
            end
            task.wait(GIVEITEM_ATTEMPT_DELAY)
        end
        if not state.hasPistol then pushLog("Pistol acquisition: failed after attempts") end
        state.tryingToGetPistol = false
        alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s")
            :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
    end)
end

local function grabAllItems()
    if state.tryingToGetPistol then pushLog("Already attempting to get items") return end
    state.tryingToGetPistol = true
    pushLog("Item grabber: starting aggressive gather...")
    spawn(function()
        local startCount = LocalPlayer:FindFirstChild("Folder") and #LocalPlayer.Folder:GetChildren() or 0
        local attempts = 0
        while attempts < GIVEITEM_MAX_ATTEMPTS do
            pcall(tryClickGiversOnce)
            pcall(tryPickupDroppedOnce)
            attempts = attempts + 1
            local nowCount = LocalPlayer:FindFirstChild("Folder") and #LocalPlayer.Folder:GetChildren() or 0
            if nowCount > startCount then
                pushLog("Item grabber: new items obtained after "..tostring(attempts).." attempts")
                break
            end
            task.wait(GIVEITEM_ATTEMPT_DELAY)
        end
        if attempts >= GIVEITEM_MAX_ATTEMPTS then pushLog("Item grabber: finished with no new items") end
        state.tryingToGetPistol = false
    end)
end

grabBtn.MouseButton1Click:Connect(function() grabAllItems() end)

-- pistol loss watcher and general folder checker
spawn(function()
    local folder = LocalPlayer:FindFirstChild("Folder", 10)
    if folder then
        folder.ChildRemoved:Connect(function(child)
            if child.Name == "Pistol" then
                state.hasPistol = false
                pushLog("Pistol lost from inventory")
                alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s")
                    :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
                if state.killAura or state.silentAim then ensurePistol() end
            end
        end)
    end
    while true do
        if state.hasPistol and not (LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol")) then
            state.hasPistol = false
            pushLog("Pistol no longer detected")
            alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s")
                :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
            if state.killAura or state.silentAim then ensurePistol() end
        end
        task.wait(PISTOL_CHECK_INTERVAL)
    end
end)

-- ===== team/enemy helper =====
local function teamString(pl)
    if not pl then return "" end
    return tostring(pl.Team)
end

local function isEnemyTeam(myTeam, theirTeam)
    if myTeam == "Police" then
        return theirTeam == "Criminal"
    end
    if myTeam == "Criminal" or myTeam == "Prisoner" then
        return theirTeam == "Police"
    end
    return myTeam ~= theirTeam
end

-- ===== target selection =====
local function getNearestEnemy(maxRange)
    maxRange = maxRange or DEFAULT_KILL_RANGE
    local nearestDistance = maxRange
    local nearestEnemy = nil
    local myTeam = teamString(LocalPlayer)
    local priorityActive = (tick() - lastDamageTime) < DAMAGE_PRIORITY_WINDOW and lastDamagePosition
    local myPos = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position) or Vector3.new()
    for _,v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
            local theirTeam = teamString(v)
            if isEnemyTeam(myTeam, theirTeam) then
                local distToMyPos = (v.Character.HumanoidRootPart.Position - myPos).Magnitude
                local dist = distToMyPos
                if priorityActive then
                    local pdist = (v.Character.HumanoidRootPart.Position - lastDamagePosition).Magnitude
                    dist = pdist
                    if distToMyPos > maxRange then
                        continue
                    end
                end
                if dist < nearestDistance then
                    nearestDistance = dist
                    nearestEnemy = v
                end
            end
        end
    end
    return nearestEnemy
end

-- ===== damage watcher =====
spawn(function()
    while main and main.Parent do
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Humanoid") then
            local hum = char.Humanoid
            if lastHealth == nil then lastHealth = hum.Health end
            if hum.Health < lastHealth then
                lastDamageTime = tick()
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then lastDamagePosition = hrp.Position end
                pushLog("Local damage detected; prioritization active for "..tostring(DAMAGE_PRIORITY_WINDOW).."s")
            end
            lastHealth = hum.Health
        end
        task.wait(0.25)
    end
end)

-- ===== silent aim override =====
function updateSilentAimOverride(enabled)
    if not RayCastModule or not oldRayIgnore then
        return
    end
    if enabled then
        RayCastModule.RayIgnoreNonCollideWithIgnoreList = function(...)
            local nearestEnemy = getNearestEnemy(state.killRange or DEFAULT_KILL_RANGE)
            local arg = {oldRayIgnore(...) }
            if (tostring(getfenv(2).script) == "BulletEmitter" or tostring(getfenv(2).script) == "Taser") and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") then
                arg[1] = nearestEnemy.Character.HumanoidRootPart
                arg[2] = nearestEnemy.Character.HumanoidRootPart.Position
            end
            return unpack(arg)
        end
        ensurePistol()
    else
        pcall(function() RayCastModule.RayIgnoreNonCollideWithIgnoreList = oldRayIgnore end)
    end
end

-- ===== kill aura loop =====
function runKillAura(character)
    if not character then return end
    state.killLoopId = state.killLoopId + 1
    local myLoopId = state.killLoopId
    pushLog("KillAura loop started (id "..tostring(myLoopId)..")")
    if not state.hasPistol then ensurePistol() end
    spawn(function()
        while true do
            if state.killLoopId ~= myLoopId then break end
            if not state.killAura then break end
            if not character or not character.Parent then break end
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then break end

            if not state.hasPistol then
                if not state.tryingToGetPistol then ensurePistol() end
                task.wait(KILLAURA_TICK)
            else
                local nearestEnemy = getNearestEnemy(state.killRange or DEFAULT_KILL_RANGE)
                if nearestEnemy then
                    pcall(function()
                        if RayCastModule and oldRayIgnore then
                            RayCastModule.RayIgnoreNonCollideWithIgnoreList = function(...)
                                local arg = {oldRayIgnore(...) }
                                if (tostring(getfenv(2).script) == "BulletEmitter" or tostring(getfenv(2).script) == "Taser") and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") and nearestEnemy.Character:FindFirstChild("Humanoid") and (nearestEnemy.Character.HumanoidRootPart.Position - hrp.Position).Magnitude < (state.killRange or DEFAULT_KILL_RANGE) and nearestEnemy.Character.Humanoid.Health > 0 then
                                    arg[1] = nearestEnemy.Character.HumanoidRootPart
                                    arg[2] = nearestEnemy.Character.HumanoidRootPart.Position
                                end
                                return unpack(arg)
                            end
                        end
                    end)

                    if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then
                        local shotCount = 0
                        pcall(function() LocalPlayer.Folder.Pistol.InventoryEquipRemote:FireServer(true) end)
                        task.wait(EQUIP_WAIT_TIME)
                        while state.killAura and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") and nearestEnemy.Character:FindFirstChild("Humanoid") and nearestEnemy.Character.Humanoid.Health > 0 and (nearestEnemy.Character.HumanoidRootPart.Position - hrp.Position).Magnitude < (state.killRange or DEFAULT_KILL_RANGE) do
                            local currentGun = nil
                            pcall(function() currentGun = require(ReplicatedStorage.Game.ItemSystem.ItemSystem).GetLocalEquipped() end)
                            if currentGun then
                                pcall(function() require(ReplicatedStorage.Game.Item.Gun)._attemptShoot(currentGun) end)
                                shotCount = shotCount + 1
                                if shotCount % 50 == 0 then pushLog("Fired " .. tostring(shotCount) .. " shots at " .. nearestEnemy.Name) end
                            end
                            task.wait(FIRE_DELAY)
                        end
                        pcall(function() LocalPlayer.Folder.Pistol.InventoryEquipRemote:FireServer(false) end)
                    end

                    pcall(function() if RayCastModule and oldRayIgnore then RayCastModule.RayIgnoreNonCollideWithIgnoreList = oldRayIgnore end end)
                end
                task.wait(KILLAURA_TICK)
            end
        end
        pushLog("KillAura loop stopped (id "..tostring(myLoopId)..")")
        alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s")
            :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
    end)
end

-- ===== respawn handling =====
LocalPlayer.CharacterAdded:Connect(function(char)
    pushLog("Character respawned")
    lastHealth = char:FindFirstChild("Humanoid") and char.Humanoid.Health or nil
    if state.killAura then spawn(function() runKillAura(char) end) end
    if state.silentAim then updateSilentAimOverride(true) end
    if state.keyBypass then
        pcall(function()
            local plrUtils = ReplicatedStorage:FindFirstChild("Game") and ReplicatedStorage.Game:FindFirstChild("PlayerUtils")
            if plrUtils then require(plrUtils).hasKey = function() return true end end
        end)
    end
    if state.esp then
        for _,pl in ipairs(Players:GetPlayers()) do spawn(function() pcall(function() setupESPForPlayer(pl) end) end) end
    end
end)

-- initial check for pistol
if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then
    state.hasPistol = true
    pushLog("Pistol present on load")
end

-- ===== minimize / restore logic (status stays visible) =====
local savedMainPosition
local savedMainSize

btnMin.MouseButton1Click:Connect(function()
    savedMainPosition = main.Position
    savedMainSize = main.Size

    -- hide main UI but keep status strip visible
    main.Visible = false
    minimizedBtn.Position = UDim2.new(0, main.AbsolutePosition.X, 0, main.AbsolutePosition.Y)
    minimizedBtn.Visible = true
end)

minimizedBtn.MouseButton1Click:Connect(function()
    minimizedBtn.Visible = false
    main.Visible = true
    main.Position = savedMainPosition or UDim2.new(0.5, -325, 0.5, -170)
    main.Size = savedMainSize or UDim2.new(0, 650, 0, 340)
end)

-- ===== close confirmation =====
btnClose.MouseButton1Click:Connect(function()
    confirmationFrame.Visible = true
end)
btnNo.MouseButton1Click:Connect(function()
    confirmationFrame.Visible = false
end)
btnYes.MouseButton1Click:Connect(function()
    confirmationFrame.Visible = false
    -- disable features
    state.keyBypass = false
    state.esp = false
    state.killAura = false
    state.silentAim = false
    state.killLoopId = state.killLoopId + 1
    if RayCastModule and oldRayIgnore then
        pcall(function() RayCastModule.RayIgnoreNonCollideWithIgnoreList = oldRayIgnore end)
    end
    if screenGui then screenGui:Destroy() end
end)

pushLog("Smile B UI loaded and running")
_G.SmileB = { state = state, pushLog = pushLog, ensurePistol = ensurePistol }
