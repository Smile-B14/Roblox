-- Jailbreak | Smile B — Consolidated working LocalScript
-- Paste into StarterPlayerScripts (LocalScript)
-- ===== services =====
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
-- ===== configuration =====
local DEFAULT_KILL_RANGE = 2500
local KILLAURA_TICK = 0.22
local GIVEITEM_ATTEMPT_DELAY = 0.35
local GIVEITEM_MAX_ATTEMPTS = 250
local DAMAGE_PRIORITY_WINDOW = 3
local LOG_CAP = 50
local ESP_UPDATE_INTERVAL = 0.1
local PISTOL_CHECK_INTERVAL = 0.5
local EQUIP_WAIT_TIME = 0.5
local FIRE_DELAY = 0.15
local UI_FADE_TIME = 0.3
-- ===== state =====
local state = {
    keyBypass = false,
    esp = false,
    killAura = false,
    silentAim = false,
    killRange = DEFAULT_KILL_RANGE,
    hasPistol = false,
    tryingToGetPistol = false,
    killLoopId = 0,
    currentTarget = nil,
    previousTargetColor = nil
}
local logs = {} -- string array (keeps up to LOG_CAP)
local lastHealth = nil
local lastDamageTime = 0
-- ===== UI placeholders (declared early so functions can reference) =====
local screenGui, main, logsList, logsScroll, logsFrame, alwaysVisibleStatus, confirmationFrame = nil, nil, nil, nil, nil, nil, nil
-- pushLog: append to logs array, print, and add to UI if ready
local function pushLog(msg)
    local entry = ("[%s] %s"):format(os.date("%H:%M:%S"), tostring(msg))
    table.insert(logs, entry)
    if #logs > LOG_CAP then table.remove(logs, 1) end
    print("[SmileB] " .. entry)
    -- UI update if logsList present
    if logsList and logsScroll then
        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.new(1, -8, 0, 18)
        lbl.BackgroundTransparency = 1
        lbl.Text = entry
        lbl.Font = Enum.Font.SourceSans
        lbl.TextSize = 14
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        lbl.TextColor3 = Color3.fromRGB(220,220,220)
        lbl.Parent = logsList
        -- trim UI children to LOG_CAP
        local count = 0
        for _,c in ipairs(logsList:GetChildren()) do if c:IsA("TextLabel") then count = count + 1 end end
        while count > LOG_CAP do
            for _,c in ipairs(logsList:GetChildren()) do
                if c:IsA("TextLabel") then c:Destroy(); count = count - 1; break end
            end
        end
        -- update canvas size using AbsoluteContentSize for accuracy
        task.defer(function()
            local logsLayout = logsList:FindFirstChildOfClass("UIListLayout")
            if logsLayout then
                logsScroll.CanvasSize = UDim2.new(0, 0, 0, logsLayout.AbsoluteContentSize.Y + 4)
                logsScroll.CanvasPosition = Vector2.new(0, logsLayout.AbsoluteContentSize.Y + 4)
            end
        end)
    end
end
-- ===== fade functions for smooth UI transitions =====
local function setTransparency(obj, transparency)
    if obj:IsA("Frame") or obj:IsA("ScrollingFrame") then
        obj.BackgroundTransparency = transparency
    elseif obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
        obj.TextTransparency = transparency
        obj.BackgroundTransparency = transparency
    elseif obj:IsA("ImageLabel") or obj:IsA("ImageButton") then
        obj.ImageTransparency = transparency
        obj.BackgroundTransparency = transparency
    end
end
local function tweenTransparency(obj, goal, time)
    local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(obj, tweenInfo, goal)
    tween:Play()
    return tween
end
local function fadeRecursive(parent, transparency, time)
    local tweens = {}
    setTransparency(parent, transparency) -- immediate set for parent
    table.insert(tweens, tweenTransparency(parent, {BackgroundTransparency = transparency, TextTransparency = transparency, ImageTransparency = transparency}, time))
    for _, child in ipairs(parent:GetChildren()) do
        local childTweens = fadeRecursive(child, transparency, time)
        for _, t in ipairs(childTweens) do
            table.insert(tweens, t)
        end
    end
    return tweens
end
local function fadeIn(frame, time)
    fadeRecursive(frame, 1, 0) -- set to transparent immediately
    frame.Visible = true
    local tweens = fadeRecursive(frame, 0, time)
    return tweens
end
local function fadeOut(frame, time)
    local tweens = fadeRecursive(frame, 1, time)
    for _, t in ipairs(tweens) do
        t.Completed:Wait()
    end
    frame.Visible = false
end
-- ===== build UI =====
screenGui = Instance.new("ScreenGui")
screenGui.Name = "SmileB_JailbreakUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = PlayerGui
-- always visible status indicators
alwaysVisibleStatus = Instance.new("TextLabel")
alwaysVisibleStatus.Size = UDim2.new(0, 500, 0, 20)
alwaysVisibleStatus.Position = UDim2.new(1, -510, 0, 10)
alwaysVisibleStatus.BackgroundColor3 = Color3.fromRGB(20,20,22)
alwaysVisibleStatus.BorderSizePixel = 0
alwaysVisibleStatus.Font = Enum.Font.SourceSans
alwaysVisibleStatus.TextSize = 12
alwaysVisibleStatus.TextXAlignment = Enum.TextXAlignment.Left
alwaysVisibleStatus.TextColor3 = Color3.fromRGB(200,200,200)
alwaysVisibleStatus.Text = "Pistol: No • KillAura: OFF • SilentAim: OFF • ESP: OFF • KeyBypass: OFF"
alwaysVisibleStatus.Parent = screenGui
-- main frame (wider and shorter)
main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0, 650, 0, 320)
main.Position = UDim2.new(0, 36, 0, 36)
main.BackgroundColor3 = Color3.fromRGB(20,20,22)
main.BorderSizePixel = 0
main.Active = true
main.Draggable = true
main.Parent = screenGui
-- header
local header = Instance.new("Frame", main)
header.Size = UDim2.new(1,0,0,40)
header.BackgroundColor3 = Color3.fromRGB(28,28,30)
header.BorderSizePixel = 0
local title = Instance.new("TextLabel", header)
title.Position = UDim2.new(0,12,0,0)
title.Size = UDim2.new(1,-160,1,0)
title.BackgroundTransparency = 1
title.Text = "Jailbreak | Smile B"
title.Font = Enum.Font.SourceSansBold
title.TextSize = 16
title.TextXAlignment = Enum.TextXAlignment.Left
title.TextColor3 = Color3.fromRGB(200,200,255)
local btnMin = Instance.new("TextButton", header)
btnMin.Size = UDim2.new(0,28,0,28)
btnMin.Position = UDim2.new(1,-110,0,6)
btnMin.Text = "—"
btnMin.Font = Enum.Font.SourceSansBold
btnMin.BackgroundColor3 = Color3.fromRGB(36,36,40)
btnMin.TextColor3 = Color3.fromRGB(255,223,120)
btnMin.BorderSizePixel = 0
local btnClose = Instance.new("TextButton", header)
btnClose.Size = UDim2.new(0,28,0,28)
btnClose.Position = UDim2.new(1,-70,0,6)
btnClose.Text = "X"
btnClose.Font = Enum.Font.SourceSansBold
btnClose.BackgroundColor3 = Color3.fromRGB(36,36,40)
btnClose.TextColor3 = Color3.fromRGB(255,120,120)
btnClose.BorderSizePixel = 0
-- minimized button
local minimizedBtn = Instance.new("TextButton", screenGui)
minimizedBtn.Size = UDim2.new(0,140,0,30)
minimizedBtn.Position = UDim2.new(0,36,0,36)
minimizedBtn.Text = "Smile B | JB"
minimizedBtn.Font = Enum.Font.SourceSansBold
minimizedBtn.TextSize = 14
minimizedBtn.BackgroundColor3 = Color3.fromRGB(36,36,40)
minimizedBtn.TextColor3 = Color3.fromRGB(240,240,240)
minimizedBtn.Visible = false
minimizedBtn.BorderSizePixel = 0
btnMin.MouseButton1Click:Connect(function()
    fadeOut(main, UI_FADE_TIME)
    minimizedBtn.Visible = true
end)
minimizedBtn.MouseButton1Click:Connect(function()
    minimizedBtn.Visible = false
    fadeIn(main, UI_FADE_TIME)
end)
-- confirmation frame for close
confirmationFrame = Instance.new("Frame")
confirmationFrame.Size = UDim2.new(0, 300, 0, 150)
confirmationFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
confirmationFrame.BackgroundColor3 = Color3.fromRGB(30,30,32)
confirmationFrame.BorderSizePixel = 0
confirmationFrame.Visible = false
confirmationFrame.Parent = screenGui
local confTitle = Instance.new("TextLabel", confirmationFrame)
confTitle.Size = UDim2.new(1,0,0,40)
confTitle.BackgroundTransparency = 1
confTitle.Text = "Are you sure?"
confTitle.Font = Enum.Font.SourceSansBold
confTitle.TextSize = 18
confTitle.TextColor3 = Color3.fromRGB(255,255,255)
local confText = Instance.new("TextLabel", confirmationFrame)
confText.Size = UDim2.new(1,0,0,60)
confText.Position = UDim2.new(0,0,0,40)
confText.BackgroundTransparency = 1
confText.Text = "Closing will disable all features."
confText.Font = Enum.Font.SourceSans
confText.TextSize = 14
confText.TextColor3 = Color3.fromRGB(220,220,220)
confText.TextWrapped = true
local btnYes = Instance.new("TextButton", confirmationFrame)
btnYes.Size = UDim2.new(0.4,0,0,30)
btnYes.Position = UDim2.new(0.1,0,1,-40)
btnYes.Text = "Yes"
btnYes.Font = Enum.Font.SourceSansBold
btnYes.BackgroundColor3 = Color3.fromRGB(255,80,80)
btnYes.TextColor3 = Color3.fromRGB(255,255,255)
btnYes.BorderSizePixel = 0
local btnNo = Instance.new("TextButton", confirmationFrame)
btnNo.Size = UDim2.new(0.4,0,0,30)
btnNo.Position = UDim2.new(0.5,0,1,-40)
btnNo.Text = "No"
btnNo.Font = Enum.Font.SourceSansBold
btnNo.BackgroundColor3 = Color3.fromRGB(80,80,80)
btnNo.TextColor3 = Color3.fromRGB(255,255,255)
btnNo.BorderSizePixel = 0
btnClose.MouseButton1Click:Connect(function()
    confirmationFrame.Visible = true
end)
btnNo.MouseButton1Click:Connect(function()
    confirmationFrame.Visible = false
end)
btnYes.MouseButton1Click:Connect(function()
    -- disable all features
    state.keyBypass = false
    local ok, plrUtils = pcall(function() return ReplicatedStorage:FindFirstChild("Game") and ReplicatedStorage.Game:FindFirstChild("PlayerUtils") end)
    if ok and plrUtils then
        pcall(function() require(plrUtils).hasKey = rawget(_G, "SmileB_original_hasKey") or require(plrUtils).hasKey end)
        pushLog("Keycard bypass disabled")
    end
    state.esp = false
    for p,h in pairs(highlightMap) do pcall(function() h:Destroy() end) highlightMap[p] = nil end
    for p,b in pairs(nameTagMap) do pcall(function() b:Destroy() end) nameTagMap[p] = nil end
    pushLog("ESP disabled")
    state.killAura = false
    state.killLoopId = state.killLoopId + 1
    pushLog("KillAura disabled")
    state.silentAim = false
    updateSilentAimOverride(false)
    pushLog("Silent Aim disabled")
    -- destroy gui
    screenGui:Destroy()
end)
-- layout: left controls + right logs
local left = Instance.new("Frame", main)
left.Size = UDim2.new(0.45, -12, 1, -52)
left.Position = UDim2.new(0, 8, 0, 44)
left.BackgroundTransparency = 1
local right = Instance.new("Frame", main)
right.Size = UDim2.new(0.55, -12, 1, -52)
right.Position = UDim2.new(0.45, 6, 0, 44)
right.BackgroundTransparency = 0.02
right.BackgroundColor3 = Color3.fromRGB(14,14,16)
right.BorderSizePixel = 0
right.ClipsDescendants = true
local leftLayout = Instance.new("UIListLayout", left)
leftLayout.SortOrder = Enum.SortOrder.LayoutOrder
leftLayout.Padding = UDim.new(0,8)
-- small helpers for rows/ui
local function newRow(parent, height)
    height = height or 32
    local f = Instance.new("Frame")
    f.Size = UDim2.new(1,0,0,height)
    f.BackgroundTransparency = 1
    f.Parent = parent
    return f
end
local function createToggle(parent, labelText, default, callback)
    local row = newRow(parent,34)
    local lbl = Instance.new("TextLabel", row)
    lbl.Size = UDim2.new(0.6,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = labelText
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 14
    lbl.TextColor3 = Color3.fromRGB(230,230,230)
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    local btn = Instance.new("TextButton", row)
    btn.Size = UDim2.new(0,64,0,26)
    btn.Position = UDim2.new(1,-72,0,4)
    btn.Text = default and "ON" or "OFF"
    btn.Font = Enum.Font.SourceSansBold
    btn.TextSize = 13
    btn.BorderSizePixel = 0
    btn.BackgroundColor3 = default and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    local st = default
    btn.MouseButton1Click:Connect(function()
        st = not st
        btn.Text = st and "ON" or "OFF"
        btn.BackgroundColor3 = st and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
        callback(st)
    end)
    return row, btn
end
local function createSlider(parent, name, min, max, default, callback)
    local row = newRow(parent,36)
    local lbl = Instance.new("TextLabel", row)
    lbl.Size = UDim2.new(0.58,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = name .. ": " .. tostring(default)
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 14
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    local slider = Instance.new("Frame", row)
    slider.Size = UDim2.new(0.38,0,0.45,0)
    slider.Position = UDim2.new(0.6,0,0.275,0)
    slider.BackgroundColor3 = Color3.fromRGB(60,60,60)
    slider.BorderSizePixel = 0
    slider.ClipsDescendants = true
    local fill = Instance.new("Frame", slider)
    fill.Size = UDim2.new((default-min)/(max-min),0,1,0)
    fill.BackgroundColor3 = Color3.fromRGB(128,0,128)
    fill.BorderSizePixel = 0
    local dragging = false
    local conn
    local function updateFromPos(pos)
        local x = math.clamp(pos.X - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X)
        local pct = x / slider.AbsoluteSize.X
        local value = math.floor(min + pct * (max - min))
        fill.Size = UDim2.new(pct,0,1,0)
        lbl.Text = name .. ": " .. tostring(value)
        callback(value)
    end
    slider.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            main.Draggable = false
            conn = UserInputService.InputChanged:Connect(function(move)
                if dragging and (move.UserInputType == Enum.UserInputType.MouseMovement or move.UserInputType == Enum.UserInputType.Touch) then
                    updateFromPos(move.Position)
                end
            end)
        end
    end)
    slider.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
            main.Draggable = true
            if conn then conn:Disconnect(); conn = nil end
        end
    end)
    return row, slider, fill, lbl
end
-- ===== left controls =====
-- Keycard toggle
createToggle(left, "Keycard Bypass", false, function(v)
    state.keyBypass = v
    local ok, plrUtils = pcall(function() return ReplicatedStorage:FindFirstChild("Game") and ReplicatedStorage.Game:FindFirstChild("PlayerUtils") end)
    if ok and plrUtils then
        if v then
            if not rawget(_G, "SmileB_original_hasKey") then
                pcall(function() rawset(_G, "SmileB_original_hasKey", require(plrUtils).hasKey) end)
            end
            pcall(function() require(plrUtils).hasKey = function() return true end end)
            pushLog("Keycard bypass enabled")
        else
            pcall(function() require(plrUtils).hasKey = rawget(_G, "SmileB_original_hasKey") or require(plrUtils).hasKey end)
            pushLog("Keycard bypass disabled")
        end
    else
        pushLog("Keycard bypass: PlayerUtils not found")
    end
    alwaysVisibleStatus.Text = ("Pistol: %s • KillAura: %s • SilentAim: %s • ESP: %s • KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
end)
-- KillAura toggle
createToggle(left, "KillAura (requires pistol)", false, function(v)
    state.killAura = v
    pushLog("KillAura toggled: "..tostring(v))
    if v and LocalPlayer.Character then
        spawn(function() runKillAura(LocalPlayer.Character) end)
    else
        -- stop by incrementing loop id
        state.killLoopId = state.killLoopId + 1
    end
    alwaysVisibleStatus.Text = ("Pistol: %s • KillAura: %s • SilentAim: %s • ESP: %s • KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
end)
-- SilentAim toggle
createToggle(left, "Silent Aim (requires pistol)", false, function(v)
    state.silentAim = v
    pushLog("Silent Aim toggled: "..tostring(v))
    updateSilentAimOverride(v)
    alwaysVisibleStatus.Text = ("Pistol: %s • KillAura: %s • SilentAim: %s • ESP: %s • KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
end)
-- Shared Range slider
local _,_,_, killLabel = createSlider(left, "Range (KillAura/Silent)", 100, 5000, DEFAULT_KILL_RANGE, function(v)
    state.killRange = v
    killLabel.Text = "Range (KillAura/Silent): "..tostring(v)
end)
state.killRange = DEFAULT_KILL_RANGE
-- ESP toggle
createToggle(left, "ESP (Police/Criminals)", false, function(v)
    state.esp = v
    pushLog("ESP toggled: "..tostring(v))
    if not v then
        -- cleanup all highlights & tags
        for p,h in pairs(highlightMap) do pcall(function() h:Destroy() end) highlightMap[p] = nil end
        for p,b in pairs(nameTagMap) do pcall(function() b:Destroy() end) nameTagMap[p] = nil end
    else
        for _,pl in pairs(Players:GetPlayers()) do spawn(function() pcall(function() setupESPForPlayer(pl) end) end) end
    end
    alwaysVisibleStatus.Text = ("Pistol: %s • KillAura: %s • SilentAim: %s • ESP: %s • KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
end)
-- ===== right logs panel =====
local logsTitle = Instance.new("TextLabel", right)
logsTitle.Size = UDim2.new(1,0,0,26)
logsTitle.Position = UDim2.new(0,0,0,4)
logsTitle.BackgroundTransparency = 1
logsTitle.Text = "Logs (last "..LOG_CAP..")"
logsTitle.Font = Enum.Font.SourceSansBold
logsTitle.TextSize = 14
logsTitle.TextColor3 = Color3.fromRGB(220,220,220)
local clearBtn = Instance.new("TextButton", right)
clearBtn.Size = UDim2.new(0,64,0,24)
clearBtn.Position = UDim2.new(1,-72,0,4)
clearBtn.Text = "Clear"
clearBtn.Font = Enum.Font.SourceSans
clearBtn.TextSize = 12
clearBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
clearBtn.TextColor3 = Color3.fromRGB(240,240,240)
clearBtn.BorderSizePixel = 0
logsScroll = Instance.new("ScrollingFrame", right)
logsScroll.Size = UDim2.new(1,-8,1,-44)
logsScroll.Position = UDim2.new(0,4,0,36)
logsScroll.BackgroundTransparency = 1
logsScroll.ScrollBarThickness = 8
logsList = Instance.new("Frame", logsScroll)
logsList.Size = UDim2.new(1,0,1,0)
logsList.BackgroundTransparency = 1
logsList.Name = "LogsList"
local logsLayout = Instance.new("UIListLayout", logsList)
logsLayout.SortOrder = Enum.SortOrder.LayoutOrder
logsLayout.Padding = UDim.new(0,4)
clearBtn.MouseButton1Click:Connect(function()
    for _,c in ipairs(logsList:GetChildren()) do if c:IsA("TextLabel") then c:Destroy() end end
    logs = {}
    pushLog("Logs cleared")
end)
-- ===== ESP (robust) =====
local highlightMap = {}
local nameTagMap = {}
local function teamColorForPlayer(p)
    if not p then return Color3.fromRGB(200,200,200) end
    local t = tostring(p.Team)
    if t == "Police" then return Color3.fromRGB(0,122,255) end
    if t == "Criminal" then return Color3.fromRGB(255,40,40) end
    return p.TeamColor and p.TeamColor.Color or Color3.fromRGB(200,200,200)
end
local function makeNameTagFor(p)
    if not p.Character then return nil end
    local head = p.Character:FindFirstChild("Head")
    if not head then return nil end
    local bg = Instance.new("BillboardGui")
    bg.Name = "SmileB_NameTag"
    bg.Size = UDim2.new(0,160,0,28)
    bg.StudsOffset = Vector3.new(0,2.2,0)
    bg.AlwaysOnTop = true
    bg.Adornee = head
    local txt = Instance.new("TextLabel", bg)
    txt.Size = UDim2.new(1,0,1,0)
    txt.BackgroundTransparency = 1
    txt.Font = Enum.Font.SourceSansBold
    txt.TextScaled = true
    txt.Text = p.Name
    txt.TextColor3 = teamColorForPlayer(p)
    txt.TextStrokeTransparency = 0
    return bg, txt
end
function setupESPForPlayer(p)
    if not state.esp or not p or not p.Character then return end
    pcall(function()
        if highlightMap[p] and highlightMap[p].Parent then highlightMap[p]:Destroy() end
        local existing = p.Character:FindFirstChild("SmileB_Highlight")
        if existing then existing:Destroy() end
        local hl = Instance.new("Highlight")
        hl.Name = "SmileB_Highlight"
        hl.Adornee = p.Character
        hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        hl.Parent = p.Character
        highlightMap[p] = hl
        hl.FillColor = teamColorForPlayer(p)
    end)
    pcall(function()
        if nameTagMap[p] and nameTagMap[p].Parent then nameTagMap[p]:Destroy() end
        local bg, txt = makeNameTagFor(p)
        if bg then bg.Parent = p.Character; nameTagMap[p] = bg end
    end)
end
function cleanupESPForPlayer(p)
    if highlightMap[p] then pcall(function() highlightMap[p]:Destroy() end) highlightMap[p] = nil end
    if nameTagMap[p] then pcall(function() nameTagMap[p]:Destroy() end) nameTagMap[p] = nil end
end
function updateESPColorFor(p)
    if not state.esp then return end
    if highlightMap[p] and highlightMap[p].Parent then highlightMap[p].FillColor = teamColorForPlayer(p) end
    if nameTagMap[p] and nameTagMap[p].Parent then
        local lbl = nameTagMap[p]:FindFirstChildWhichIsA("TextLabel")
        if lbl then lbl.TextColor3 = teamColorForPlayer(p) end
    end
end
-- ESP event watchers
Players.PlayerAdded:Connect(function(pl)
    pl.CharacterAdded:Connect(function() if state.esp then setupESPForPlayer(pl) end end)
    pl:GetPropertyChangedSignal("TeamColor"):Connect(function() updateESPColorFor(pl) end)
end)
Players.PlayerRemoving:Connect(function(pl) cleanupESPForPlayer(pl) end)
for _,pl in ipairs(Players:GetPlayers()) do
    pl.CharacterAdded:Connect(function() if state.esp then setupESPForPlayer(pl) end end)
    pl:GetPropertyChangedSignal("TeamColor"):Connect(function() updateESPColorFor(pl) end)
end
-- render step to keep ESP accurate & persistent after death
spawn(function()
    while main and main.Parent do
        if state.esp then
            local myChar = LocalPlayer.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            for _,pl in ipairs(Players:GetPlayers()) do
                if pl ~= LocalPlayer then
                    if pl.Character then
                        if not highlightMap[pl] then pcall(function() setupESPForPlayer(pl) end) end
                        pcall(function() updateESPColorFor(pl) end)
                        -- update distance in name tag
                        if nameTagMap[pl] and nameTagMap[pl].Parent then
                            local theirRoot = pl.Character:FindFirstChild("HumanoidRootPart")
                            local dist = myRoot and theirRoot and math.floor((myRoot.Position - theirRoot.Position).Magnitude) or "?"
                            local lbl = nameTagMap[pl]:FindFirstChildWhichIsA("TextLabel")
                            if lbl then lbl.Text = pl.Name .. " (" .. tostring(dist) .. " studs)" end
                        end
                    else
                        pcall(function() cleanupESPForPlayer(pl) end)
                    end
                end
            end
        end
        task.wait(ESP_UPDATE_INTERVAL)
    end
end)
-- ===== pistol acquisition (Workspace.Givers click detectors) =====
local function tryClickGiversOnce()
    if not Workspace:FindFirstChild("Givers") then return false end
    for _,g in ipairs(Workspace.Givers:GetChildren()) do
        if not g or not g.Parent then continue end
        local cd = g:FindFirstChildWhichIsA("ClickDetector")
        if cd then
            pcall(function() fireclickdetector(cd) end)
            task.wait(0.06)
            if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then return true end
        end
    end
    return false
end
local function ensurePistol()
    if state.tryingToGetPistol or state.hasPistol then return end
    state.tryingToGetPistol = true
    pushLog("Pistol acquisition: scanning Givers...")
    spawn(function()
        local attempts = 0
        while not state.hasPistol and attempts < GIVEITEM_MAX_ATTEMPTS do
            local ok, res = pcall(tryClickGiversOnce)
            attempts = attempts + 1
            if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then
                state.hasPistol = true
                pushLog("Pistol obtained after "..tostring(attempts).." attempts")
                break
            end
            task.wait(GIVEITEM_ATTEMPT_DELAY)
        end
        if not state.hasPistol then
            pushLog("Pistol acquisition: failed after attempts")
        end
        state.tryingToGetPistol = false
        alwaysVisibleStatus.Text = ("Pistol: %s • KillAura: %s • SilentAim: %s • ESP: %s • KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
    end)
end
-- pistol loss watcher
spawn(function()
    local folder = LocalPlayer:WaitForChild("Folder", 10)
    if folder then
        folder.ChildRemoved:Connect(function(child)
            if child.Name == "Pistol" then
                state.hasPistol = false
                pushLog("Pistol lost from inventory")
                alwaysVisibleStatus.Text = ("Pistol: %s • KillAura: %s • SilentAim: %s • ESP: %s • KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
                if state.killAura or state.silentAim then ensurePistol() end
            end
        end)
    end
    while true do
        if state.hasPistol and not (LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol")) then
            state.hasPistol = false
            pushLog("Pistol no longer detected")
            alwaysVisibleStatus.Text = ("Pistol: %s • KillAura: %s • SilentAim: %s • ESP: %s • KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
            if state.killAura or state.silentAim then ensurePistol() end
        end
        task.wait(PISTOL_CHECK_INTERVAL)
    end
end)
-- ===== target selection =====
local function getNearestEnemy(maxRange)
    local nearestDistance, nearestEnemy = maxRange, nil
    local myTeam = tostring(LocalPlayer.Team)
    for i,v in pairs(Players:GetPlayers()) do
        local theirTeam = tostring(v.Team)
        if ((myTeam == "Police" and theirTeam == "Criminal") or theirTeam == "Police") and theirTeam ~= myTeam and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
            local dist = (v.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            if dist < nearestDistance then
                nearestDistance = dist
                nearestEnemy = v
            end
        end
    end
    return nearestEnemy
end
-- safe oldRayIgnore require
local oldRayIgnore = require(ReplicatedStorage.Module.RayCast).RayIgnoreNonCollideWithIgnoreList
-- ===== silent aim override =====
local function updateSilentAimOverride(enabled)
    if enabled then
        require(ReplicatedStorage.Module.RayCast).RayIgnoreNonCollideWithIgnoreList = function(...)
            local nearestDistance, nearestEnemy = state.killRange or DEFAULT_KILL_RANGE, nil
            local myTeam = tostring(LocalPlayer.Team)
            for i,v in pairs(Players:GetPlayers()) do
                local theirTeam = tostring(v.Team)
                if ((myTeam == "Police" and theirTeam == "Criminal") or theirTeam == "Police") and theirTeam ~= myTeam and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
                    local dist = (v.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if dist < nearestDistance then
                        nearestDistance = dist
                        nearestEnemy = v
                    end
                end
            end
            local arg = {oldRayIgnore(...)}
            if (tostring(getfenv(2).script) == "BulletEmitter" or tostring(getfenv(2).script) == "Taser") and nearestEnemy then
                arg[1] = nearestEnemy.Character.HumanoidRootPart
                arg[2] = nearestEnemy.Character.HumanoidRootPart.Position
            end
            return unpack(arg)
        end
    else
        require(ReplicatedStorage.Module.RayCast).RayIgnoreNonCollideWithIgnoreList = oldRayIgnore
    end
end
-- ===== kill aura loop (cancelable via loopId) =====
function runKillAura(character)
    if not character then return end
    state.killLoopId = state.killLoopId + 1
    local myLoopId = state.killLoopId
    pushLog("KillAura loop started (id "..tostring(myLoopId)..")")
    -- start ensure pistol if not present
    if not state.hasPistol then
        ensurePistol()
    end
    spawn(function()
        while true do
            if state.killLoopId ~= myLoopId then break end
            if not state.killAura then break end
            if not character or not character.Parent then break end
            if not character:FindFirstChild("HumanoidRootPart") then break end
            -- ensure pistol
            if not state.hasPistol then
                if not state.tryingToGetPistol then ensurePistol() end
                task.wait(KILLAURA_TICK)
                continue
            end
            local nearestEnemy = getNearestEnemy(state.killRange or DEFAULT_KILL_RANGE)
            if nearestEnemy then
                -- set override
                pcall(function()
                    require(ReplicatedStorage.Module.RayCast).RayIgnoreNonCollideWithIgnoreList = function(...)
                        local arg = {oldRayIgnore(...)}
                        if (tostring(getfenv(2).script) == "BulletEmitter" or tostring(getfenv(2).script) == "Taser") and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") and nearestEnemy.Character:FindFirstChild("Humanoid") and (nearestEnemy.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude < (state.killRange or DEFAULT_KILL_RANGE) and nearestEnemy.Character.Humanoid.Health > 0 then
                            arg[1] = nearestEnemy.Character.HumanoidRootPart
                            arg[2] = nearestEnemy.Character.HumanoidRootPart.Position
                        end
                        return unpack(arg)
                    end
                end)
                -- equip and shoot
                if LocalPlayer.Folder:FindFirstChild("Pistol") then
                    local shotCount = 0
                    LocalPlayer.Folder.Pistol.InventoryEquipRemote:FireServer(true)
                    task.wait(EQUIP_WAIT_TIME)
                    while state.killAura and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") and nearestEnemy.Character:FindFirstChild("Humanoid") and (nearestEnemy.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude < (state.killRange or DEFAULT_KILL_RANGE) and nearestEnemy.Character.Humanoid.Health > 0 do
                        local currentGun = require(ReplicatedStorage.Game.ItemSystem.ItemSystem).GetLocalEquipped()
                        if currentGun then
                            require(ReplicatedStorage.Game.Item.Gun)._attemptShoot(currentGun)
                            shotCount = shotCount + 1
                            if shotCount % 50 == 0 then
                                pushLog("Fired " .. tostring(shotCount) .. " shots at " .. nearestEnemy.Name)
                            end
                        end
                        task.wait(FIRE_DELAY)
                    end
                    LocalPlayer.Folder.Pistol.InventoryEquipRemote:FireServer(false)
                end
                -- restore override
                pcall(function()
                    require(ReplicatedStorage.Module.RayCast).RayIgnoreNonCollideWithIgnoreList = oldRayIgnore
                end)
            end
            task.wait(KILLAURA_TICK)
        end
        pushLog("KillAura loop stopped (id "..tostring(myLoopId)..")")
        alwaysVisibleStatus.Text = ("Pistol: %s • KillAura: %s • SilentAim: %s • ESP: %s • KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"))
    end)
end
-- ===== damage watcher =====
spawn(function()
    while main and main.Parent do
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Humanoid") then
            local hum = char.Humanoid
            if lastHealth == nil then lastHealth = hum.Health end
            if hum.Health < lastHealth then
                lastDamageTime = tick()
                pushLog("Local damage detected; prioritization active for "..tostring(DAMAGE_PRIORITY_WINDOW).."s")
            end
            lastHealth = hum.Health
        end
        task.wait(0.25)
    end
end)
-- ===== respawn handling =====
LocalPlayer.CharacterAdded:Connect(function(char)
    pushLog("Character respawned")
    lastHealth = char:FindFirstChild("Humanoid") and char.Humanoid.Health or nil
    if state.killAura then
        spawn(function() runKillAura(char) end)
    end
    if state.silentAim then
        updateSilentAimOverride(true)
    end
    if state.keyBypass then
        pcall(function()
            local plrUtils = ReplicatedStorage:FindFirstChild("Game") and ReplicatedStorage.Game:FindFirstChild("PlayerUtils")
            if plrUtils then require(plrUtils).hasKey = function() return true end end
        end)
    end
    if state.esp then
        for _,pl in ipairs(Players:GetPlayers()) do spawn(function() pcall(function() setupESPForPlayer(pl) end) end) end
    end
end)
-- initial check for pistol
if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then
    state.hasPistol = true
    pushLog("Pistol present on load")
end
-- show initial log
pushLog("Smile B UI loaded and running")
-- expose debugging helpers
_G.SmileB = { state = state, pushLog = pushLog, ensurePistol = ensurePistol }
-- done
