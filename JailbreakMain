-- Smile B | Jailbreak — Full Centralized & Redesigned LocalScript (with draggable UI, autodrop, keybinds, credits)
-- Paste into StarterPlayerScripts (LocalScript)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- ===== configuration =====
local DEFAULT_KILL_RANGE = 1000
local KILLAURA_TICK = 0.22
local GIVEITEM_ATTEMPT_DELAY = 0.18
local GIVEITEM_MAX_ATTEMPTS = 400
local DAMAGE_PRIORITY_WINDOW = 3
local LOG_CAP = 50
local ESP_UPDATE_INTERVAL = 0.1
local ESP_FULL_RELOAD_INTERVAL = 2.5
local PISTOL_CHECK_INTERVAL = 0.5
local UI_FADE_TIME = 0.25

local EQUIP_WAIT_TIME = 0.12
local FIRE_DELAY = 0.06

local UI_CORNER_RADIUS = UDim.new(0, 12)

-- ===== state =====
local state = {
    keyBypass = false,
    esp = false,
    killAura = false,
    silentAim = false,
    killRange = DEFAULT_KILL_RANGE,
    hasPistol = false,
    tryingToGetPistol = false,
    killLoopId = 0,
    currentTarget = nil,
    autoDrop = false,
    autoDropLoopId = 0,
    keybinds = {
        KillAura = Enum.KeyCode.K,
        SilentAim = Enum.KeyCode.L,
        ESP = Enum.KeyCode.E,
        Keycard = Enum.KeyCode.B,
        Grab = Enum.KeyCode.G,
        AutoDrop = Enum.KeyCode.Backspace
    }
}
local logs = {}
local lastHealth = nil
local lastDamageTime = 0
local lastDamagePosition = nil

-- ===== cached modules (if any) =====
local RayCastModule
pcall(function()
    RayCastModule = ReplicatedStorage:FindFirstChild("Module") and require(ReplicatedStorage.Module.RayCast)
end)
local oldRayIgnore = RayCastModule and RayCastModule.RayIgnoreNonCollideWithIgnoreList

-- helper to add UICorner uniformly
local function addCorner(inst)
    if not inst then return end
    local c = Instance.new("UICorner")
    c.CornerRadius = UI_CORNER_RADIUS
    c.Parent = inst
    return c
end

-- ===== GUI =====
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "SmileB_JailbreakUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = PlayerGui

-- status strip
local alwaysVisibleStatus = Instance.new("TextLabel")
alwaysVisibleStatus.Name = "StatusStrip"
alwaysVisibleStatus.Size = UDim2.new(0, 520, 0, 30)
alwaysVisibleStatus.Position = UDim2.new(0.98, -540, 0, 10)
alwaysVisibleStatus.AnchorPoint = Vector2.new(1, 0)
alwaysVisibleStatus.BackgroundTransparency = 0.18
alwaysVisibleStatus.BackgroundColor3 = Color3.fromRGB(40,40,40)
alwaysVisibleStatus.BorderSizePixel = 0
alwaysVisibleStatus.Font = Enum.Font.SourceSans
alwaysVisibleStatus.TextSize = 13
alwaysVisibleStatus.TextXAlignment = Enum.TextXAlignment.Left
alwaysVisibleStatus.TextColor3 = Color3.fromRGB(230,230,230)
alwaysVisibleStatus.Text = "Pistol: No  KillAura: OFF  SilentAim: OFF  ESP: OFF  KeyBypass: OFF  AutoDrop: OFF"
alwaysVisibleStatus.Parent = screenGui
addCorner(alwaysVisibleStatus)

-- main container
local main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0, 700, 0, 380)
main.Position = UDim2.new(0.5, -350, 0.5, -190) -- center spawn
main.BackgroundColor3 = Color3.fromRGB(30,30,30)
main.BorderSizePixel = 0
main.Active = true
main.Parent = screenGui
addCorner(main)

-- header
local header = Instance.new("Frame", main)
header.Name = "Header"
header.Size = UDim2.new(1,0,0,46)
header.BackgroundColor3 = Color3.fromRGB(28,28,30)
header.BorderSizePixel = 0
addCorner(header)

local title = Instance.new("TextLabel", header)
title.Name = "Title"
title.Position = UDim2.new(0,12,0,0)
title.Size = UDim2.new(1,-200,1,0)
title.BackgroundTransparency = 1
title.Text = "Jailbreak | Smile B"
title.Font = Enum.Font.SourceSansBold
title.TextSize = 16
title.TextXAlignment = Enum.TextXAlignment.Left
title.TextColor3 = Color3.fromRGB(200,200,255)

-- minimize, close
local btnMin = Instance.new("TextButton", header)
btnMin.Name = "BtnMin"
btnMin.Size = UDim2.new(0,34,0,30)
btnMin.Position = UDim2.new(1,-154,0,8)
btnMin.Text = "—"
btnMin.Font = Enum.Font.SourceSansBold
btnMin.BackgroundColor3 = Color3.fromRGB(36,36,40)
btnMin.TextColor3 = Color3.fromRGB(255,223,120)
btnMin.BorderSizePixel = 0
addCorner(btnMin)

local btnClose = Instance.new("TextButton", header)
btnClose.Name = "BtnClose"
btnClose.Size = UDim2.new(0,34,0,30)
btnClose.Position = UDim2.new(1,-108,0,8)
btnClose.Text = "x"
btnClose.Font = Enum.Font.SourceSansBold
btnClose.BackgroundColor3 = Color3.fromRGB(36,36,40)
btnClose.TextColor3 = Color3.fromRGB(255,120,120)
btnClose.BorderSizePixel = 0
addCorner(btnClose)

-- tab bar
local tabBar = Instance.new("Frame", main)
tabBar.Name = "TabBar"
tabBar.Size = UDim2.new(1, -16, 0, 36)
tabBar.Position = UDim2.new(0,8,0,52)
tabBar.BackgroundTransparency = 1
local tabLayout = Instance.new("UIListLayout", tabBar)
tabLayout.FillDirection = Enum.FillDirection.Horizontal
tabLayout.SortOrder = Enum.SortOrder.LayoutOrder
tabLayout.Padding = UDim.new(0,6)

local function makeTab(label)
    local b = Instance.new("TextButton", tabBar)
    b.Size = UDim2.new(0, 120, 1, 0)
    b.Text = label
    b.Font = Enum.Font.SourceSansBold
    b.TextSize = 14
    b.BackgroundColor3 = Color3.fromRGB(40,40,40)
    b.BorderSizePixel = 0
    addCorner(b)
    return b
end

local tabMainBtn = makeTab("Main")
local tabKeybindBtn = makeTab("Keybinds")
local tabCreditsBtn = makeTab("Credits")

-- content panels
local contentMain = Instance.new("Frame", main)
contentMain.Name = "ContentMain"
contentMain.Size = UDim2.new(1, -16, 1, -110)
contentMain.Position = UDim2.new(0,8,0,100)
contentMain.BackgroundTransparency = 1
addCorner(contentMain)

local contentKeybinds = Instance.new("Frame", main)
contentKeybinds.Name = "ContentKeybinds"
contentKeybinds.Size = contentMain.Size
contentKeybinds.Position = contentMain.Position
contentKeybinds.BackgroundTransparency = 1
contentKeybinds.Visible = false
addCorner(contentKeybinds)

local contentCredits = Instance.new("Frame", main)
contentCredits.Name = "ContentCredits"
contentCredits.Size = contentMain.Size
contentCredits.Position = contentMain.Position
contentCredits.BackgroundTransparency = 1
contentCredits.Visible = false
addCorner(contentCredits)

-- left & right inside main content
local left = Instance.new("Frame", contentMain)
left.Name = "LeftPanel"
left.Size = UDim2.new(0.48, -8, 1, 0)
left.Position = UDim2.new(0,0,0,0)
left.BackgroundTransparency = 1
addCorner(left)
local leftLayout = Instance.new("UIListLayout", left)
leftLayout.SortOrder = Enum.SortOrder.LayoutOrder
leftLayout.Padding = UDim.new(0,8)

local right = Instance.new("Frame", contentMain)
right.Name = "RightPanel"
right.Size = UDim2.new(0.52, -8, 1, 0)
right.Position = UDim2.new(0.48, 8, 0, 0)
right.BackgroundColor3 = Color3.fromRGB(14,14,16)
right.BorderSizePixel = 0
right.ClipsDescendants = true
addCorner(right)

-- logs area in right panel
local logsTitle = Instance.new("TextLabel", right)
logsTitle.Size = UDim2.new(1,0,0,26)
logsTitle.Position = UDim2.new(0,0,0,6)
logsTitle.BackgroundTransparency = 1
logsTitle.Text = "Logs (last "..LOG_CAP..")"
logsTitle.Font = Enum.Font.SourceSansBold
logsTitle.TextSize = 14
logsTitle.TextColor3 = Color3.fromRGB(220,220,220)

local clearBtn = Instance.new("TextButton", right)
clearBtn.Size = UDim2.new(0,72,0,28)
clearBtn.Position = UDim2.new(1,-84,0,6)
clearBtn.Text = "Clear"
clearBtn.Font = Enum.Font.SourceSans
clearBtn.TextSize = 12
clearBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
clearBtn.TextColor3 = Color3.fromRGB(240,240,240)
clearBtn.BorderSizePixel = 0
addCorner(clearBtn)

local logsScroll = Instance.new("ScrollingFrame", right)
logsScroll.Name = "LogsScroll"
logsScroll.Size = UDim2.new(1,-12,1,-56)
logsScroll.Position = UDim2.new(0,6,0,36)
logsScroll.BackgroundTransparency = 1
logsScroll.ScrollBarThickness = 8
addCorner(logsScroll)
local logsList = Instance.new("Frame", logsScroll)
logsList.Name = "LogsList"
logsList.Size = UDim2.new(1,0,1,0)
logsList.BackgroundTransparency = 1
local logsLayout2 = Instance.new("UIListLayout", logsList)
logsLayout2.SortOrder = Enum.SortOrder.LayoutOrder
logsLayout2.Padding = UDim.new(0,4)

local function pushLog(msg)
    local entry = ("[%s] %s"):format(os.date("%H:%M:%S"), tostring(msg))
    table.insert(logs, entry)
    if #logs > LOG_CAP then table.remove(logs, 1) end
    print("[SmileB] " .. entry)
    if logsList and logsScroll then
        local lbl = Instance.new("TextLabel")
        lbl.Size = UDim2.new(1, -8, 0, 18)
        lbl.BackgroundTransparency = 1
        lbl.Text = entry
        lbl.Font = Enum.Font.SourceSans
        lbl.TextSize = 14
        lbl.TextXAlignment = Enum.TextXAlignment.Left
        lbl.TextColor3 = Color3.fromRGB(220,220,220)
        lbl.Parent = logsList
        task.defer(function()
            local layout = logsList:FindFirstChildOfClass("UIListLayout")
            if layout then
                logsScroll.CanvasSize = UDim2.new(0,0,0,layout.AbsoluteContentSize.Y + 8)
                logsScroll.CanvasPosition = Vector2.new(0, layout.AbsoluteContentSize.Y + 8)
            end
        end)
    end
end

clearBtn.MouseButton1Click:Connect(function()
    for _,c in ipairs(logsList:GetChildren()) do if c:IsA("TextLabel") then c:Destroy() end end
    logs = {}
    pushLog("Logs cleared")
end)

-- helper row creators
local function newRow(parent, height)
    height = height or 34
    local f = Instance.new("Frame")
    f.Size = UDim2.new(1,0,0,height)
    f.BackgroundTransparency = 1
    f.Parent = parent
    return f
end

local function createToggle(parent, labelText, default, callback)
    local row = newRow(parent,34)
    local lbl = Instance.new("TextLabel", row)
    lbl.Size = UDim2.new(0.62,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = labelText
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 14
    lbl.TextColor3 = Color3.fromRGB(230,230,230)
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local btn = Instance.new("TextButton", row)
    btn.Size = UDim2.new(0,84,0,28)
    btn.Position = UDim2.new(1,-92,0,3)
    btn.Text = default and "ON" or "OFF"
    btn.Font = Enum.Font.SourceSansBold
    btn.TextSize = 13
    btn.BorderSizePixel = 0
    btn.BackgroundColor3 = default and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    addCorner(btn)

    local st = default
    btn.MouseButton1Click:Connect(function()
        st = not st
        btn.Text = st and "ON" or "OFF"
        btn.BackgroundColor3 = st and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
        callback(st)
    end)
    return row, btn
end

local function createSlider(parent, name, min, max, default, callback)
    local row = newRow(parent,40)
    local lbl = Instance.new("TextLabel", row)
    lbl.Size = UDim2.new(0.6,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = name .. ": " .. tostring(default)
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 14
    lbl.TextColor3 = Color3.fromRGB(220,220,220)
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local slider = Instance.new("Frame", row)
    slider.Size = UDim2.new(0.36,0,0.45,0)
    slider.Position = UDim2.new(0.62,0,0.275,0)
    slider.BackgroundColor3 = Color3.fromRGB(60,60,60)
    slider.BorderSizePixel = 0
    slider.ClipsDescendants = true
    addCorner(slider)

    local fill = Instance.new("Frame", slider)
    fill.Size = UDim2.new((default-min)/(max-min),0,1,0)
    fill.BackgroundColor3 = Color3.fromRGB(128,0,128)
    fill.BorderSizePixel = 0
    addCorner(fill)

    local dragging = false
    local conn
    local function updateFromPos(pos)
        local x = math.clamp(pos.X - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X)
        local pct = x / slider.AbsoluteSize.X
        local value = math.floor(min + pct * (max - min))
        fill.Size = UDim2.new(pct,0,1,0)
        lbl.Text = name .. ": " .. tostring(value)
        callback(value)
    end
    slider.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            conn = UserInputService.InputChanged:Connect(function(move)
                if dragging and (move.UserInputType == Enum.UserInputType.MouseMovement or move.UserInputType == Enum.UserInputType.Touch) then
                    updateFromPos(move.Position)
                end
            end)
        end
    end)
    slider.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
            if conn then conn:Disconnect(); conn = nil end
        end
    end)
    return row, slider, fill, lbl
end

-- ===== left controls =====
-- Keycard toggle
local keyRow, keyBtn = createToggle(left, "Keycard Bypass", false, function(v)
    state.keyBypass = v
    local ok, plrUtils = pcall(function() return ReplicatedStorage:FindFirstChild("Game") and ReplicatedStorage.Game:FindFirstChild("PlayerUtils") end)
    if ok and plrUtils then
        if v then
            if not rawget(_G, "SmileB_original_hasKey") then pcall(function() rawset(_G, "SmileB_original_hasKey", require(plrUtils).hasKey) end) end
            pcall(function() require(plrUtils).hasKey = function() return true end end)
            pushLog("Keycard bypass enabled")
        else
            pcall(function() require(plrUtils).hasKey = rawget(_G, "SmileB_original_hasKey") or require(plrUtils).hasKey end)
            pushLog("Keycard bypass disabled")
        end
    else
        pushLog("Keycard bypass: PlayerUtils not found")
    end
    alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
        :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
end)

-- KillAura toggle
local kaRow, kaBtn = createToggle(left, "KillAura (1000 Recommended)", false, function(v)
    state.killAura = v
    pushLog("KillAura toggled: "..tostring(v))
    if v and LocalPlayer.Character then
        spawn(function() runKillAura(LocalPlayer.Character) end)
    else
        state.killLoopId = state.killLoopId + 1
    end
    alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
        :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
end)

-- SilentAim toggle
local saRow, saBtn = createToggle(left, "Silent Aim", false, function(v)
    state.silentAim = v
    pushLog("Silent Aim toggled: "..tostring(v))
    updateSilentAimOverride(v)
    if v then ensurePistol() end
    alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
        :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
end)

-- Range slider
local _,_,_, killLabel = createSlider(left, "Range (KillAura/Silent)", 100, 5000, DEFAULT_KILL_RANGE, function(v)
    state.killRange = v
    killLabel.Text = "Range (KillAura/Silent): "..tostring(v)
end)
state.killRange = DEFAULT_KILL_RANGE

-- ESP toggle
local espRow, espBtn = createToggle(left, "ESP", false, function(v)
    state.esp = v
    pushLog("ESP toggled: "..tostring(v))
    if not v then
        for p,h in pairs(highlightMap) do pcall(function() h:Destroy() end) highlightMap[p] = nil end
        for p,b in pairs(nameTagMap) do pcall(function() b:Destroy() end) nameTagMap[p] = nil end
    else
        for _,pl in pairs(Players:GetPlayers()) do spawn(function() pcall(function() setupESPForPlayer(pl) end) end) end
    end
    alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
        :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
end)

-- Grab Items button
local grabRow = newRow(left, 36)
local grabLbl = Instance.new("TextLabel", grabRow)
grabLbl.Size = UDim2.new(0.62,0,1,0)
grabLbl.BackgroundTransparency = 1
grabLbl.Text = "Grab Items"
grabLbl.Font = Enum.Font.SourceSans
grabLbl.TextSize = 14
grabLbl.TextColor3 = Color3.fromRGB(230,230,230)
grabLbl.TextXAlignment = Enum.TextXAlignment.Left

local grabBtn = Instance.new("TextButton", grabRow)
grabBtn.Size = UDim2.new(0,84,0,28)
grabBtn.Position = UDim2.new(1,-92,0,3)
grabBtn.Text = "Grab"
grabBtn.Font = Enum.Font.SourceSansBold
grabBtn.TextSize = 13
grabBtn.BorderSizePixel = 0
grabBtn.BackgroundColor3 = Color3.fromRGB(70,70,70)
grabBtn.TextColor3 = Color3.fromRGB(255,255,255)
addCorner(grabBtn)

-- Auto Drop toggle
local autoDropRow, autoDropBtn = createToggle(left, "Auto Drop Guns", false, function(v)
    state.autoDrop = v
    if v then
        state.autoDropLoopId = state.autoDropLoopId + 1
        spawn(function()
            local myLoop = state.autoDropLoopId
            pushLog("AutoDrop: started")
            while state.autoDrop and state.autoDropLoopId == myLoop do
                -- scan folder for guns
                local folder = LocalPlayer:FindFirstChild("Folder")
                if folder then
                    for _,child in ipairs(folder:GetChildren()) do
                        local name = tostring(child.Name):lower()
                        if string.find(name, "pistol") or string.find(name, "shotgun") or string.find(name, "rifle") or string.find(name, "gun") then
                            pcall(function()
                                local success = false
                                -- try common remote names
                                if child:FindFirstChild("InventoryDropRemote") and child.InventoryDropRemote.FireServer then
                                    pcall(function() child.InventoryDropRemote:FireServer() success = true end)
                                end
                                if not success and LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("InventoryDrop") and type(LocalPlayer.Folder.InventoryDrop.FireServer) == "function" then
                                    pcall(function() LocalPlayer.Folder.InventoryDrop:FireServer(child) success = true end)
                                end
                                -- fallback: try to move to workspace near HRP (may not persist server-side)
                                if not success then
                                    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                                    pcall(function()
                                        if child:IsA("Model") or child:IsA("Tool") then
                                            child.Parent = Workspace
                                            if hrp and child:FindFirstChildWhichIsA("BasePart") then
                                                local bp = child:FindFirstChildWhichIsA("BasePart")
                                                bp.CFrame = hrp.CFrame * CFrame.new(0, -2, 2)
                                            end
                                            success = true
                                        end
                                    end)
                                end
                                if success then
                                    pushLog("AutoDrop: dropped " .. tostring(child.Name))
                                else
                                    pushLog("AutoDrop: failed to drop " .. tostring(child.Name))
                                end
                            end)
                        end
                    end
                end
                task.wait(0.6)
            end
            pushLog("AutoDrop: stopped")
        end)
    else
        state.autoDropLoopId = state.autoDropLoopId + 1
    end
    alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
        :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
end)

-- ==== right panel logs already handled ====


-- ===== ESP helpers (unchanged) =====
local highlightMap = {}
local nameTagMap = {}

local function teamColorForPlayer(p)
    if not p then return Color3.fromRGB(200,200,200) end
    local t = tostring(p.Team)
    if t == "Police" then return Color3.fromRGB(0,122,255) end
    if t == "Criminal" then return Color3.fromRGB(255,40,40) end
    return p.TeamColor and p.TeamColor.Color or Color3.fromRGB(200,200,200)
end

local function makeNameTagFor(p)
    if not p.Character then return nil end
    local head = p.Character:FindFirstChild("Head")
    if not head then return nil end
    local bg = Instance.new("BillboardGui")
    bg.Name = "SmileB_NameTag"
    bg.Size = UDim2.new(0,160,0,28)
    bg.StudsOffset = Vector3.new(0,2.2,0)
    bg.AlwaysOnTop = true
    bg.Adornee = head
    local txt = Instance.new("TextLabel", bg)
    txt.Size = UDim2.new(1,0,1,0)
    txt.BackgroundTransparency = 1
    txt.Font = Enum.Font.SourceSansBold
    txt.TextScaled = true
    txt.Text = p.Name
    txt.TextColor3 = teamColorForPlayer(p)
    txt.TextStrokeTransparency = 0
    return bg, txt
end

function setupESPForPlayer(p)
    if not state.esp or not p or not p.Character then return end
    pcall(function()
        if highlightMap[p] and highlightMap[p].Parent then highlightMap[p]:Destroy() end
        local existing = p.Character:FindFirstChild("SmileB_Highlight")
        if existing then existing:Destroy() end
        local hl = Instance.new("Highlight")
        hl.Name = "SmileB_Highlight"
        hl.Adornee = p.Character
        hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        hl.Parent = p.Character
        highlightMap[p] = hl
        hl.FillColor = teamColorForPlayer(p)
    end)
    pcall(function()
        if nameTagMap[p] and nameTagMap[p].Parent then nameTagMap[p]:Destroy() end
        local bg, txt = makeNameTagFor(p)
        if bg then bg.Parent = p.Character; nameTagMap[p] = bg end
    end)
end

function cleanupESPForPlayer(p)
    if highlightMap[p] then pcall(function() highlightMap[p]:Destroy() end) highlightMap[p] = nil end
    if nameTagMap[p] then pcall(function() nameTagMap[p]:Destroy() end) nameTagMap[p] = nil end
end

function updateESPColorFor(p)
    if not state.esp then return end
    if highlightMap[p] and highlightMap[p].Parent then highlightMap[p].FillColor = teamColorForPlayer(p) end
    if nameTagMap[p] and nameTagMap[p].Parent then
        local lbl = nameTagMap[p]:FindFirstChildWhichIsA("TextLabel")
        if lbl then lbl.TextColor3 = teamColorForPlayer(p) end
    end
end

Players.PlayerAdded:Connect(function(pl)
    pl.CharacterAdded:Connect(function() if state.esp then setupESPForPlayer(pl) end end)
    pl:GetPropertyChangedSignal("TeamColor"):Connect(function() updateESPColorFor(pl) end)
end)
Players.PlayerRemoving:Connect(function(pl) cleanupESPForPlayer(pl) end)
for _,pl in ipairs(Players:GetPlayers()) do
    pl.CharacterAdded:Connect(function() if state.esp then setupESPForPlayer(pl) end end)
    pl:GetPropertyChangedSignal("TeamColor"):Connect(function() updateESPColorFor(pl) end)
end

spawn(function()
    while main and main.Parent do
        if state.esp then
            local myChar = LocalPlayer.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            for _,pl in ipairs(Players:GetPlayers()) do
                if pl ~= LocalPlayer then
                    if pl.Character then
                        if not highlightMap[pl] then pcall(function() setupESPForPlayer(pl) end) end
                        pcall(function() updateESPColorFor(pl) end)
                        if nameTagMap[pl] and nameTagMap[pl].Parent then
                            local theirRoot = pl.Character:FindFirstChild("HumanoidRootPart")
                            local dist = myRoot and theirRoot and math.floor((myRoot.Position - theirRoot.Position).Magnitude) or "?"
                            local lbl = nameTagMap[pl]:FindFirstChildWhichIsA("TextLabel")
                            if lbl then lbl.Text = pl.Name .. " (" .. tostring(dist) .. " studs)" end
                        end
                    else
                        pcall(function() cleanupESPForPlayer(pl) end)
                    end
                end
            end
        end
        task.wait(ESP_UPDATE_INTERVAL)
    end
end)

spawn(function()
    while main and main.Parent do
        if state.esp then
            for _,pl in ipairs(Players:GetPlayers()) do
                pcall(function()
                    cleanupESPForPlayer(pl)
                    setupESPForPlayer(pl)
                end)
            end
        end
        task.wait(ESP_FULL_RELOAD_INTERVAL)
    end
end)

-- ===== pistol acquisition / grabbing logic (kept and reused) =====
local function tryClickGiversOnce()
    if not Workspace:FindFirstChild("Givers") then return false end
    for _,g in ipairs(Workspace.Givers:GetChildren()) do
        if not g or not g.Parent then continue end
        local cd = g:FindFirstChildWhichIsA("ClickDetector")
        if cd then
            pcall(function() fireclickdetector(cd) end)
            task.wait(0.04)
            if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then return true end
        end
    end
    return false
end

local function tryPickupDroppedOnce()
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    local found = false
    for _,obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Parent and obj.Parent:IsA("Model") then
            local name = tostring(obj.Name):lower()
            if string.find(name, "pistol") or string.find(name, "gun") or string.find(name, "rifle") or string.find(name, "shotgun") or string.find(name, "ammo") or string.find(name, "cash") or string.find(name, "money") or string.find(name, "bag") or string.find(name, "drop") then
                pcall(function()
                    firetouchinterest(obj, hrp, 0)
                    task.wait(0.03)
                    firetouchinterest(obj, hrp, 1)
                    task.wait(0.05)
                end)
                found = true
                if LocalPlayer:FindFirstChild("Folder") and #LocalPlayer.Folder:GetChildren() > 0 then
                    return true
                end
            end
        end
    end
    return found
end

local function ensurePistol()
    if state.tryingToGetPistol or state.hasPistol then return end
    state.tryingToGetPistol = true
    pushLog("Pistol acquisition: scanning Givers...")
    spawn(function()
        local attempts = 0
        while not state.hasPistol and attempts < GIVEITEM_MAX_ATTEMPTS do
            pcall(tryClickGiversOnce)
            pcall(tryPickupDroppedOnce)
            attempts = attempts + 1
            if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then
                state.hasPistol = true
                pushLog("Pistol obtained after "..tostring(attempts).." attempts")
                break
            end
            task.wait(GIVEITEM_ATTEMPT_DELAY)
        end
        if not state.hasPistol then pushLog("Pistol acquisition: failed after attempts") end
        state.tryingToGetPistol = false
        alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
            :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
    end)
end

local function grabAllItems()
    if state.tryingToGetPistol then pushLog("Already attempting to get items") return end
    state.tryingToGetPistol = true
    pushLog("Item grabber: starting aggressive gather...")
    spawn(function()
        local startCount = LocalPlayer:FindFirstChild("Folder") and #LocalPlayer.Folder:GetChildren() or 0
        local attempts = 0
        while attempts < GIVEITEM_MAX_ATTEMPTS do
            pcall(tryClickGiversOnce)
            pcall(tryPickupDroppedOnce)
            attempts = attempts + 1
            local nowCount = LocalPlayer:FindFirstChild("Folder") and #LocalPlayer.Folder:GetChildren() or 0
            if nowCount > startCount then
                pushLog("Item grabber: new items obtained after "..tostring(attempts).." attempts")
                break
            end
            task.wait(GIVEITEM_ATTEMPT_DELAY)
        end
        if attempts >= GIVEITEM_MAX_ATTEMPTS then pushLog("Item grabber: finished with no new items") end
        state.tryingToGetPistol = false
    end)
end

grabBtn.MouseButton1Click:Connect(function() grabAllItems() end)

-- pistol loss watcher
spawn(function()
    local folder = LocalPlayer:FindFirstChild("Folder", 10)
    if folder then
        folder.ChildRemoved:Connect(function(child)
            if child.Name == "Pistol" then
                state.hasPistol = false
                pushLog("Pistol lost from inventory")
                alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
                    :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
                if state.killAura or state.silentAim then ensurePistol() end
            end
        end)
    end
    while true do
        if state.hasPistol and not (LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol")) then
            state.hasPistol = false
            pushLog("Pistol no longer detected")
            alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
                :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
            if state.killAura or state.silentAim then ensurePistol() end
        end
        task.wait(PISTOL_CHECK_INTERVAL)
    end
end)

-- ===== team/enemy helpers and kill aura logic (kept) =====
local function teamString(pl)
    if not pl then return "" end
    return tostring(pl.Team)
end

local function isEnemyTeam(myTeam, theirTeam)
    if myTeam == "Police" then
        return theirTeam == "Criminal"
    end
    if myTeam == "Criminal" or myTeam == "Prisoner" then
        return theirTeam == "Police"
    end
    return myTeam ~= theirTeam
end

local function getNearestEnemy(maxRange)
    maxRange = maxRange or DEFAULT_KILL_RANGE
    local nearestDistance = maxRange
    local nearestEnemy = nil
    local myTeam = teamString(LocalPlayer)
    local priorityActive = (tick() - lastDamageTime) < DAMAGE_PRIORITY_WINDOW and lastDamagePosition
    local myPos = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position) or Vector3.new()
    for _,v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then
            local theirTeam = teamString(v)
            if isEnemyTeam(myTeam, theirTeam) then
                local distToMyPos = (v.Character.HumanoidRootPart.Position - myPos).Magnitude
                local dist = distToMyPos
                if priorityActive then
                    local pdist = (v.Character.HumanoidRootPart.Position - lastDamagePosition).Magnitude
                    dist = pdist
                    if distToMyPos > maxRange then
                        continue
                    end
                end
                if dist < nearestDistance then
                    nearestDistance = dist
                    nearestEnemy = v
                end
            end
        end
    end
    return nearestEnemy
end

spawn(function()
    while main and main.Parent do
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Humanoid") then
            local hum = char.Humanoid
            if lastHealth == nil then lastHealth = hum.Health end
            if hum.Health < lastHealth then
                lastDamageTime = tick()
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then lastDamagePosition = hrp.Position end
                pushLog("Local damage detected; prioritization active for "..tostring(DAMAGE_PRIORITY_WINDOW).."s")
            end
            lastHealth = hum.Health
        end
        task.wait(0.25)
    end
end)

function updateSilentAimOverride(enabled)
    if not RayCastModule or not oldRayIgnore then
        return
    end
    if enabled then
        RayCastModule.RayIgnoreNonCollideWithIgnoreList = function(...)
            local nearestEnemy = getNearestEnemy(state.killRange or DEFAULT_KILL_RANGE)
            local arg = {oldRayIgnore(...) }
            if (tostring(getfenv(2).script) == "BulletEmitter" or tostring(getfenv(2).script) == "Taser") and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") then
                arg[1] = nearestEnemy.Character.HumanoidRootPart
                arg[2] = nearestEnemy.Character.HumanoidRootPart.Position
            end
            return unpack(arg)
        end
        ensurePistol()
    else
        pcall(function() RayCastModule.RayIgnoreNonCollideWithIgnoreList = oldRayIgnore end)
    end
end

function runKillAura(character)
    if not character then return end
    state.killLoopId = state.killLoopId + 1
    local myLoopId = state.killLoopId
    pushLog("KillAura loop started (id "..tostring(myLoopId)..")")
    if not state.hasPistol then ensurePistol() end
    spawn(function()
        while true do
            if state.killLoopId ~= myLoopId then break end
            if not state.killAura then break end
            if not character or not character.Parent then break end
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then break end

            if not state.hasPistol then
                if not state.tryingToGetPistol then ensurePistol() end
                task.wait(KILLAURA_TICK)
            else
                local nearestEnemy = getNearestEnemy(state.killRange or DEFAULT_KILL_RANGE)
                if nearestEnemy then
                    pcall(function()
                        if RayCastModule and oldRayIgnore then
                            RayCastModule.RayIgnoreNonCollideWithIgnoreList = function(...)
                                local arg = {oldRayIgnore(...) }
                                if (tostring(getfenv(2).script) == "BulletEmitter" or tostring(getfenv(2).script) == "Taser") and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") and nearestEnemy.Character:FindFirstChild("Humanoid") and (nearestEnemy.Character.HumanoidRootPart.Position - hrp.Position).Magnitude < (state.killRange or DEFAULT_KILL_RANGE) and nearestEnemy.Character.Humanoid.Health > 0 then
                                    arg[1] = nearestEnemy.Character.HumanoidRootPart
                                    arg[2] = nearestEnemy.Character.HumanoidRootPart.Position
                                end
                                return unpack(arg)
                            end
                        end
                    end)

                    if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then
                        local shotCount = 0
                        pcall(function() LocalPlayer.Folder.Pistol.InventoryEquipRemote:FireServer(true) end)
                        task.wait(EQUIP_WAIT_TIME)
                        while state.killAura and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") and nearestEnemy.Character:FindFirstChild("Humanoid") and nearestEnemy.Character.Humanoid.Health > 0 and (nearestEnemy.Character.HumanoidRootPart.Position - hrp.Position).Magnitude < (state.killRange or DEFAULT_KILL_RANGE) do
                            local currentGun = nil
                            pcall(function() currentGun = require(ReplicatedStorage.Game.ItemSystem.ItemSystem).GetLocalEquipped() end)
                            if currentGun then
                                pcall(function() require(ReplicatedStorage.Game.Item.Gun)._attemptShoot(currentGun) end)
                                shotCount = shotCount + 1
                                if shotCount % 50 == 0 then pushLog("Fired " .. tostring(shotCount) .. " shots at " .. nearestEnemy.Name) end
                            end
                            task.wait(FIRE_DELAY)
                        end
                        pcall(function() LocalPlayer.Folder.Pistol.InventoryEquipRemote:FireServer(false) end)
                    end

                    pcall(function() if RayCastModule and oldRayIgnore then RayCastModule.RayIgnoreNonCollideWithIgnoreList = oldRayIgnore end end)
                end
                task.wait(KILLAURA_TICK)
            end
        end
        pushLog("KillAura loop stopped (id "..tostring(myLoopId)..")")
        alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
            :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
    end)
end

-- respawn handling
LocalPlayer.CharacterAdded:Connect(function(char)
    pushLog("Character respawned")
    lastHealth = char:FindFirstChild("Humanoid") and char.Humanoid.Health or nil
    if state.killAura then spawn(function() runKillAura(char) end) end
    if state.silentAim then updateSilentAimOverride(true) end
    if state.keyBypass then
        pcall(function()
            local plrUtils = ReplicatedStorage:FindFirstChild("Game") and ReplicatedStorage.Game:FindFirstChild("PlayerUtils")
            if plrUtils then require(plrUtils).hasKey = function() return true end end
        end)
    end
    if state.esp then
        for _,pl in ipairs(Players:GetPlayers()) do spawn(function() pcall(function() setupESPForPlayer(pl) end) end) end
    end
end)

if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then
    state.hasPistol = true
    pushLog("Pistol present on load")
end

-- ===== minimize / restore and confirmation UI =====
local confirmationFrame = Instance.new("Frame")
confirmationFrame.Name = "Confirmation"
confirmationFrame.Size = UDim2.new(0, 320,0,160)
confirmationFrame.Position = UDim2.new(0.5,-160,0.5,-80)
confirmationFrame.BackgroundColor3 = Color3.fromRGB(30,30,32)
confirmationFrame.BorderSizePixel = 0
confirmationFrame.Visible = false
confirmationFrame.Parent = screenGui
addCorner(confirmationFrame)

local confTitle = Instance.new("TextLabel", confirmationFrame)
confTitle.Size = UDim2.new(1,0,0,44)
confTitle.BackgroundTransparency = 1
confTitle.Text = "Are you sure?"
confTitle.Font = Enum.Font.SourceSansBold
confTitle.TextSize = 18
confTitle.TextColor3 = Color3.fromRGB(255,255,255)

local confText = Instance.new("TextLabel", confirmationFrame)
confText.Size = UDim2.new(1,0,0,66)
confText.Position = UDim2.new(0,0,0,44)
confText.BackgroundTransparency = 1
confText.Text = "Closing will disable all features."
confText.Font = Enum.Font.SourceSans
confText.TextSize = 14
confText.TextColor3 = Color3.fromRGB(220,220,220)
confText.TextWrapped = true

local btnYes = Instance.new("TextButton", confirmationFrame)
btnYes.Size = UDim2.new(0.4,0,0,32)
btnYes.Position = UDim2.new(0.06,0,1,-44)
btnYes.Text = "Yes"
btnYes.Font = Enum.Font.SourceSansBold
btnYes.BackgroundColor3 = Color3.fromRGB(255,80,80)
btnYes.TextColor3 = Color3.fromRGB(255,255,255)
btnYes.BorderSizePixel = 0
addCorner(btnYes)

local btnNo = Instance.new("TextButton", confirmationFrame)
btnNo.Size = UDim2.new(0.4,0,0,32)
btnNo.Position = UDim2.new(0.54,0,1,-44)
btnNo.Text = "No"
btnNo.Font = Enum.Font.SourceSansBold
btnNo.BackgroundColor3 = Color3.fromRGB(80,80,80)
btnNo.TextColor3 = Color3.fromRGB(255,255,255)
btnNo.BorderSizePixel = 0
addCorner(btnNo)

btnClose.MouseButton1Click:Connect(function()
    confirmationFrame.Visible = true
end)
btnNo.MouseButton1Click:Connect(function()
    confirmationFrame.Visible = false
end)
btnYes.MouseButton1Click:Connect(function()
    confirmationFrame.Visible = false
    -- disable features and destroy UI
    state.keyBypass = false
    state.esp = false
    state.killAura = false
    state.silentAim = false
    state.autoDrop = false
    state.killLoopId = state.killLoopId + 1
    state.autoDropLoopId = state.autoDropLoopId + 1
    if RayCastModule and oldRayIgnore then
        pcall(function() RayCastModule.RayIgnoreNonCollideWithIgnoreList = oldRayIgnore end)
    end
    if screenGui then screenGui:Destroy() end
end)

-- floating minimized hamburger button
local minimizedBtn = Instance.new("TextButton")
minimizedBtn.Name = "MinimizedBtn"
minimizedBtn.Parent = screenGui
minimizedBtn.Size = UDim2.new(0, 56, 0, 56)
minimizedBtn.Position = UDim2.new(0, 10, 0, 100)
minimizedBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
minimizedBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
minimizedBtn.Text = "≡"
minimizedBtn.TextScaled = true
minimizedBtn.Font = Enum.Font.SourceSansBold
minimizedBtn.Visible = false
minimizedBtn.Active = true
addCorner(minimizedBtn)

-- minimize / restore
local savedMainPosition, savedMainSize = nil, nil
btnMin.MouseButton1Click:Connect(function()
    savedMainPosition = main.Position
    savedMainSize = main.Size
    main.Visible = false
    minimizedBtn.Position = UDim2.new(0, math.clamp(main.AbsolutePosition.X, 4, workspace.CurrentCamera.ViewportSize.X - minimizedBtn.AbsoluteSize.X - 4),
                                       0, math.clamp(main.AbsolutePosition.Y, 4, workspace.CurrentCamera.ViewportSize.Y - minimizedBtn.AbsoluteSize.Y - 4))
    minimizedBtn.Visible = true
end)

minimizedBtn.MouseButton1Click:Connect(function()
    minimizedBtn.Visible = false
    main.Visible = true
    main.Position = savedMainPosition or UDim2.new(0.5, -350, 0.5, -190)
    main.Size = savedMainSize or UDim2.new(0, 700, 0, 380)
end)

-- ===== keybinds UI (tab content) =====
local function makeKeybindRow(parent, actionName, defaultKey)
    local row = newRow(parent, 36)
    local lbl = Instance.new("TextLabel", row)
    lbl.Size = UDim2.new(0.5,0,1,0)
    lbl.BackgroundTransparency = 1
    lbl.Text = actionName
    lbl.Font = Enum.Font.SourceSans
    lbl.TextSize = 14
    lbl.TextColor3 = Color3.fromRGB(230,230,230)
    lbl.TextXAlignment = Enum.TextXAlignment.Left

    local keyLabel = Instance.new("TextLabel", row)
    keyLabel.Size = UDim2.new(0,120,0,28)
    keyLabel.Position = UDim2.new(0.5, 8, 0, 4)
    keyLabel.BackgroundColor3 = Color3.fromRGB(50,50,50)
    keyLabel.Text = tostring(defaultKey)
    keyLabel.Font = Enum.Font.SourceSans
    keyLabel.TextSize = 14
    keyLabel.TextColor3 = Color3.fromRGB(230,230,230)
    addCorner(keyLabel)

    local setBtn = Instance.new("TextButton", row)
    setBtn.Size = UDim2.new(0,80,0,28)
    setBtn.Position = UDim2.new(1, -88, 0, 4)
    setBtn.Text = "Set"
    setBtn.Font = Enum.Font.SourceSansBold
    setBtn.TextSize = 13
    setBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
    setBtn.BorderSizePixel = 0
    addCorner(setBtn)

    -- capture key on click
    setBtn.MouseButton1Click:Connect(function()
        setBtn.Text = "Press Key..."
        local conn
        conn = UserInputService.InputBegan:Connect(function(inp, gameProcessed)
            if gameProcessed then return end
            if inp.UserInputType == Enum.UserInputType.Keyboard and inp.KeyCode ~= Enum.KeyCode.Unknown then
                state.keybinds[actionName] = inp.KeyCode
                keyLabel.Text = tostring(inp.KeyCode):gsub("Enum.KeyCode.", "")
                setBtn.Text = "Set"
                conn:Disconnect()
            end
        end)
        -- timeout fallback
        delay(6, function()
            if conn and conn.Connected then
                conn:Disconnect()
                setBtn.Text = "Set"
            end
        end)
    end)

    return row, keyLabel, setBtn
end

-- populate keybinds tab
local keybindsLayout = Instance.new("UIListLayout", contentKeybinds)
keybindsLayout.SortOrder = Enum.SortOrder.LayoutOrder
keybindsLayout.Padding = UDim.new(0,8)

local kbTitle = Instance.new("TextLabel", contentKeybinds)
kbTitle.Size = UDim2.new(1,0,0,26)
kbTitle.BackgroundTransparency = 1
kbTitle.Text = "Keybinds"
kbTitle.Font = Enum.Font.SourceSansBold
kbTitle.TextSize = 16
kbTitle.TextColor3 = Color3.fromRGB(220,220,220)

local _r1,_k1 = makeKeybindRow(contentKeybinds, "KillAura", state.keybinds.KillAura)
local _r2,_k2 = makeKeybindRow(contentKeybinds, "SilentAim", state.keybinds.SilentAim)
local _r3,_k3 = makeKeybindRow(contentKeybinds, "ESP", state.keybinds.ESP)
local _r4,_k4 = makeKeybindRow(contentKeybinds, "Keycard", state.keybinds.Keycard)
local _r5,_k5 = makeKeybindRow(contentKeybinds, "Grab", state.keybinds.Grab)
local _r6,_k6 = makeKeybindRow(contentKeybinds, "AutoDrop", state.keybinds.AutoDrop)

-- credits tab
local creditsTitle = Instance.new("TextLabel", contentCredits)
creditsTitle.Size = UDim2.new(1,0,0,26)
creditsTitle.BackgroundTransparency = 1
creditsTitle.Text = "Credits"
creditsTitle.Font = Enum.Font.SourceSansBold
creditsTitle.TextSize = 16
creditsTitle.TextColor3 = Color3.fromRGB(220,220,220)

local creditsText = Instance.new("TextLabel", contentCredits)
creditsText.Size = UDim2.new(1,0,0,120)
creditsText.Position = UDim2.new(0,0,0,36)
creditsText.BackgroundTransparency = 1
creditsText.TextWrapped = true
creditsText.Text = "Tiktok: @SmileB.BS\nSuggest changes here: ContactSmileB@gmail.com"
creditsText.Font = Enum.Font.SourceSans
creditsText.TextSize = 14
creditsText.TextColor3 = Color3.fromRGB(220,220,220)

-- tab switching
local function showTab(tab)
    contentMain.Visible = false
    contentKeybinds.Visible = false
    contentCredits.Visible = false
    if tab == "Main" then contentMain.Visible = true end
    if tab == "Keybinds" then contentKeybinds.Visible = true end
    if tab == "Credits" then contentCredits.Visible = true end
end

tabMainBtn.MouseButton1Click:Connect(function() showTab("Main") end)
tabKeybindBtn.MouseButton1Click:Connect(function() showTab("Keybinds") end)
tabCreditsBtn.MouseButton1Click:Connect(function() showTab("Credits") end)

showTab("Main")

-- ===== key input handler to trigger toggles/actions by keybinds =====
local function isTyping()
    local focused = UserInputService:GetFocusedTextBox()
    return focused and focused ~= ""
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if isTyping() then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        local kc = input.KeyCode
        -- compare to keybinds
        for action,bind in pairs(state.keybinds) do
            if bind == kc then
                if action == "KillAura" then
                    state.killAura = not state.killAura
                    kaBtn.Text = state.killAura and "ON" or "OFF"
                    kaBtn.BackgroundColor3 = state.killAura and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
                    if state.killAura and LocalPlayer.Character then spawn(function() runKillAura(LocalPlayer.Character) end) end
                    pushLog("Keybind toggled KillAura: "..tostring(state.killAura))
                elseif action == "SilentAim" then
                    state.silentAim = not state.silentAim
                    saBtn.Text = state.silentAim and "ON" or "OFF"
                    saBtn.BackgroundColor3 = state.silentAim and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
                    updateSilentAimOverride(state.silentAim)
                    if state.silentAim then ensurePistol() end
                    pushLog("Keybind toggled SilentAim: "..tostring(state.silentAim))
                elseif action == "ESP" then
                    state.esp = not state.esp
                    espBtn.Text = state.esp and "ON" or "OFF"
                    espBtn.BackgroundColor3 = state.esp and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
                    if state.esp then for _,pl in pairs(Players:GetPlayers()) do spawn(function() pcall(function() setupESPForPlayer(pl) end) end) end end
                    pushLog("Keybind toggled ESP: "..tostring(state.esp))
                elseif action == "Keycard" then
                    state.keyBypass = not state.keyBypass
                    keyBtn.Text = state.keyBypass and "ON" or "OFF"
                    keyBtn.BackgroundColor3 = state.keyBypass and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
                    pushLog("Keybind toggled Keycard Bypass: "..tostring(state.keyBypass))
                elseif action == "Grab" then
                    pushLog("Keybind: Grab pressed")
                    grabAllItems()
                elseif action == "AutoDrop" then
                    state.autoDrop = not state.autoDrop
                    autoDropBtn.Text = state.autoDrop and "ON" or "OFF"
                    autoDropBtn.BackgroundColor3 = state.autoDrop and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70)
                    -- AutoDrop logic toggles itself already via the toggle callback
                    autoDropBtn.MouseButton1Click:Fire()
                end
                alwaysVisibleStatus.Text = ("Pistol: %s  KillAura: %s  SilentAim: %s  ESP: %s  KeyBypass: %s  AutoDrop: %s")
                    :format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF"), (state.autoDrop and "ON" or "OFF"))
                break
            end
        end
    end
end)

-- ===== dragging logic for main and minimizedBtn (clamped to viewport) =====
local function makeDraggable(guiObject)
    local dragging = false
    local dragStart = Vector2.new()
    local startPos = UDim2.new()
    local cam = workspace.CurrentCamera

    local function clampToViewport(x, y, sizeX, sizeY)
        local vw = cam and cam.ViewportSize or Vector2.new(1920,1080)
        local nx = math.clamp(x, 4, vw.X - sizeX - 4)
        local ny = math.clamp(y, 4, vw.Y - sizeY - 4)
        return nx, ny
    end

    local connB, connC, connE

    guiObject.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = guiObject.Position
            connC = UserInputService.InputChanged:Connect(function(move)
                if dragging and (move.UserInputType == Enum.UserInputType.MouseMovement or move.UserInputType == Enum.UserInputType.Touch) then
                    local delta = move.Position - dragStart
                    local newX = startPos.X.Offset + delta.X
                    local newY = startPos.Y.Offset + delta.Y
                    local sizeX = guiObject.AbsoluteSize.X
                    local sizeY = guiObject.AbsoluteSize.Y
                    local nx, ny = clampToViewport(newX, newY, sizeX, sizeY)
                    guiObject.Position = UDim2.new(0, nx, 0, ny)
                end
            end)
            connE = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    if connC then connC:Disconnect(); connC = nil end
                    if connE then connE:Disconnect(); connE = nil end
                end
            end)
        end
    end)
end

makeDraggable(main)
makeDraggable(minimizedBtn)

-- ensure main spawns centered on most devices
local cam = workspace.CurrentCamera
if cam then
    local vw = cam.ViewportSize
    main.Position = UDim2.new(0, math.floor((vw.X - main.AbsoluteSize.X)/2), 0, math.floor((vw.Y - main.AbsoluteSize.Y)/2))
end

-- finally expose the module
_G.SmileB = { state = state, pushLog = pushLog, ensurePistol = ensurePistol }

pushLog("Smile B UI loaded and running")
