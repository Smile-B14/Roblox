-- Smile B | Jailbreak — Full Centralized & Redesigned LocalScript -- Paste into StarterPlayerScripts (LocalScript) local Players = game:GetService("Players") local ReplicatedStorage = game:GetService("ReplicatedStorage") local Workspace = game:GetService("Workspace") local RunService = game:GetService("RunService") local UserInputService = game:GetService("UserInputService") local TweenService = game:GetService("TweenService") local LocalPlayer = Players.LocalPlayer local PlayerGui = LocalPlayer:WaitForChild("PlayerGui") -- ===== configuration ===== local DEFAULT_KILL_RANGE = 2500 local KILLAURA_TICK = 0.22 local GIVEITEM_ATTEMPT_DELAY = 0.18 local GIVEITEM_MAX_ATTEMPTS = 400 local DAMAGE_PRIORITY_WINDOW = 3 local LOG_CAP = 50 local ESP_UPDATE_INTERVAL = 0.1 local ESP_FULL_RELOAD_INTERVAL = 10 local PISTOL_CHECK_INTERVAL = 0.5 local UI_FADE_TIME = 0.25 -- ===== state ===== local state = { keyBypass = false, esp = false, killAura = false, silentAim = false, killRange = DEFAULT_KILL_RANGE, hasPistol = false, tryingToGetPistol = false, killLoopId = 0, currentTarget = nil } local logs = {} local lastHealth = nil local lastDamageTime = 0 local lastDamagePosition = nil -- ===== cached modules (if any) ===== local RayCastModule pcall(function() RayCastModule = ReplicatedStorage:FindFirstChild("Module") and require(ReplicatedStorage.Module.RayCast) end) local oldRayIgnore = RayCastModule and RayCastModule.RayIgnoreNonCollideWithIgnoreList -- ===== GUI ===== local screenGui = Instance.new("ScreenGui") screenGui.Name = "SmileB_JailbreakUI" screenGui.ResetOnSpawn = false screenGui.Parent = PlayerGui local alwaysVisibleStatus = Instance.new("TextLabel") alwaysVisibleStatus.Size = UDim2.new(0, 400, 0, 20) alwaysVisibleStatus.AnchorPoint = Vector2.new(0.5,0) alwaysVisibleStatus.Position = UDim2.new(0.5,0,0,10) alwaysVisibleStatus.BackgroundColor3 = Color3.fromRGB(20,20,22) alwaysVisibleStatus.BorderSizePixel = 0 alwaysVisibleStatus.Font = Enum.Font.SourceSans alwaysVisibleStatus.TextSize = 12 alwaysVisibleStatus.TextXAlignment = Enum.TextXAlignment.Left alwaysVisibleStatus.TextColor3 = Color3.fromRGB(200,200,200) alwaysVisibleStatus.Text = "Pistol: No KillAura: OFF SilentAim: OFF ESP: OFF KeyBypass: OFF" alwaysVisibleStatus.Parent = screenGui -- Main frame local main = Instance.new("Frame") main.Name = "Main" main.Size = UDim2.new(0, 650, 0, 320) main.Position = UDim2.new(0.5, -325, 0.5, -160) main.BackgroundColor3 = Color3.fromRGB(30,30,30) main.BorderSizePixel = 0 main.Active = true main.Draggable = true main.Parent = screenGui local corner = Instance.new("UICorner", main) corner.CornerRadius = UDim.new(0, 14) -- Header local header = Instance.new("Frame", main) header.Size = UDim2.new(1,0,0,40) header.BackgroundColor3 = Color3.fromRGB(28,28,30) header.BorderSizePixel = 0 local headerCorner = Instance.new("UICorner", header) headerCorner.CornerRadius = UDim.new(0, 12) local title = Instance.new("TextLabel", header) title.Position = UDim2.new(0,12,0,0) title.Size = UDim2.new(1,-160,1,0) title.BackgroundTransparency = 1 title.Text = "Jailbreak | Smile B" title.Font = Enum.Font.SourceSansBold title.TextSize = 16 title.TextXAlignment = Enum.TextXAlignment.Left title.TextColor3 = Color3.fromRGB(200,200,255) local btnMin = Instance.new("TextButton", header) btnMin.Size = UDim2.new(0,28,0,28) btnMin.Position = UDim2.new(1,-110,0,6) btnMin.Text = "–" btnMin.Font = Enum.Font.SourceSansBold btnMin.BackgroundColor3 = Color3.fromRGB(36,36,40) btnMin.TextColor3 = Color3.fromRGB(255,223,120) btnMin.BorderSizePixel = 0 local minCorner = Instance.new("UICorner", btnMin) minCorner.CornerRadius = UDim.new(0,6) local btnClose = Instance.new("TextButton", header) btnClose.Size = UDim2.new(0,28,0,28) btnClose.Position = UDim2.new(1,-70,0,6) btnClose.Text = "✕" btnClose.Font = Enum.Font.SourceSansBold btnClose.BackgroundColor3 = Color3.fromRGB(36,36,40) btnClose.TextColor3 = Color3.fromRGB(255,120,120) btnClose.BorderSizePixel = 0 local closeCorner = Instance.new("UICorner", btnClose) closeCorner.CornerRadius = UDim.new(0,6) local minimizedBtn = Instance.new("TextButton", screenGui) minimizedBtn.Size = UDim2.new(0, 40,0,40) minimizedBtn.Position = UDim2.new(0.5,-20,0.5,-20) minimizedBtn.Text = "JB" minimizedBtn.Font = Enum.Font.SourceSansBold minimizedBtn.TextSize = 16 minimizedBtn.BackgroundColor3 = Color3.fromRGB(80,80,80) minimizedBtn.TextColor3 = Color3.fromRGB(255,255,255) minimizedBtn.Visible = false local minBtnCorner = Instance.new("UICorner", minimizedBtn) minBtnCorner.CornerRadius = UDim.new(0,8) -- Confirmation frame for close local confirmationFrame = Instance.new("Frame") confirmationFrame.Size = UDim2.new(0, 300,0,150) confirmationFrame.Position = UDim2.new(0.5,-150,0.5,-75) confirmationFrame.BackgroundColor3 = Color3.fromRGB(30,30,32) confirmationFrame.BorderSizePixel = 0 confirmationFrame.Visible = false confirmationFrame.Parent = screenGui local confTitle = Instance.new("TextLabel", confirmationFrame) confTitle.Size = UDim2.new(1,0,0,40) confTitle.BackgroundTransparency = 1 confTitle.Text = "Are you sure?" confTitle.Font = Enum.Font.SourceSansBold confTitle.TextSize = 18 confTitle.TextColor3 = Color3.fromRGB(255,255,255) local confText = Instance.new("TextLabel", confirmationFrame) confText.Size = UDim2.new(1,0,0,60) confText.Position = UDim2.new(0,0,0,40) confText.BackgroundTransparency = 1 confText.Text = "Closing will disable all features." confText.Font = Enum.Font.SourceSans confText.TextSize = 14 confText.TextColor3 = Color3.fromRGB(220,220,220) confText.TextWrapped = true local btnYes = Instance.new("TextButton", confirmationFrame) btnYes.Size = UDim2.new(0.4,0,0,30) btnYes.Position = UDim2.new(0.1,0,1,-40) btnYes.Text = "Yes" btnYes.Font = Enum.Font.SourceSansBold btnYes.BackgroundColor3 = Color3.fromRGB(255,80,80) btnYes.TextColor3 = Color3.fromRGB(255,255,255) btnYes.BorderSizePixel = 0 local btnNo = Instance.new("TextButton", confirmationFrame) btnNo.Size = UDim2.new(0.4,0,0,30) btnNo.Position = UDim2.new(0.5,0,1,-40) btnNo.Text = "No" btnNo.Font = Enum.Font.SourceSansBold btnNo.BackgroundColor3 = Color3.fromRGB(80,80,80) btnNo.TextColor3 = Color3.fromRGB(255,255,255) btnNo.BorderSizePixel = 0 -- ===== Left controls + Right logs ===== local left = Instance.new("Frame", main) left.Size = UDim2.new(0.45,-12,1,-52) left.Position = UDim2.new(0,8,0,44) left.BackgroundTransparency = 1 local leftLayout = Instance.new("UIListLayout", left) leftLayout.SortOrder = Enum.SortOrder.LayoutOrder leftLayout.Padding = UDim.new(0,8) local right = Instance.new("Frame", main) right.Size = UDim2.new(0.55,-12,1,-52) right.Position = UDim2.new(0.45,6,0,44) right.BackgroundColor3 = Color3.fromRGB(14,14,16) right.BackgroundTransparency = 0.02 right.BorderSizePixel = 0 right.ClipsDescendants = true local logsTitle = Instance.new("TextLabel", right) logsTitle.Size = UDim2.new(1,0,0,26) logsTitle.Position = UDim2.new(0,0,0,4) logsTitle.BackgroundTransparency = 1 logsTitle.Text = "Logs (last "..LOG_CAP..")" logsTitle.Font = Enum.Font.SourceSansBold logsTitle.TextSize = 14 logsTitle.TextColor3 = Color3.fromRGB(220,220,220) local logsScroll = Instance.new("ScrollingFrame", right) logsScroll.Size = UDim2.new(1,-8,1,-44) logsScroll.Position = UDim2.new(0,4,0,36) logsScroll.BackgroundTransparency = 1 logsScroll.ScrollBarThickness = 8 local logsList = Instance.new("Frame", logsScroll) logsList.Size = UDim2.new(1,0,1,0) logsList.BackgroundTransparency = 1 logsList.Name = "LogsList" local logsLayout = Instance.new("UIListLayout", logsList) logsLayout.SortOrder = Enum.SortOrder.LayoutOrder logsLayout.Padding = UDim.new(0,4) -- ===== fade helpers ===== local function fadeRecursive(parent, transparency, time) local tweens = {} local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Quad, Enum.EasingDirection.Out) if parent:IsA("Frame") or parent:IsA("ScrollingFrame") then table.insert(tweens, TweenService:Create(parent, tweenInfo, {BackgroundTransparency = transparency})) elseif parent:IsA("TextLabel") or parent:IsA("TextButton") or parent:IsA("TextBox") then table.insert(tweens, TweenService:Create(parent, tweenInfo, {TextTransparency = transparency, BackgroundTransparency = transparency})) elseif parent:IsA("ImageLabel") or parent:IsA("ImageButton") then table.insert(tweens, TweenService:Create(parent, tweenInfo, {ImageTransparency = transparency, BackgroundTransparency = transparency})) end for _, child in ipairs(parent:GetChildren()) do local childTweens = fadeRecursive(child, transparency, time) for _, t in ipairs(childTweens) do table.insert(tweens, t) end end return tweens end local function fadeIn(frame, time) fadeRecursive(frame, 1, 0) frame.Visible = true fadeRecursive(frame, 0, time) end local function fadeOut(frame, time) local tweens = fadeRecursive(frame, 1, time) for _, t in ipairs(tweens) do t.Completed:Wait() end frame.Visible = false end -- ===== logging ===== local function pushLog(msg) local entry = ("[%s] %s"):format(os.date("%H:%M:%S"), tostring(msg)) table.insert(logs, entry) if #logs > LOG_CAP then table.remove(logs, 1) end print("[SmileB] " .. entry) if logsList and logsScroll then local lbl = Instance.new("TextLabel") lbl.Size = UDim2.new(1, -8, 0, 18) lbl.BackgroundTransparency = 1 lbl.Text = entry lbl.Font = Enum.Font.SourceSans lbl.TextSize = 14 lbl.TextXAlignment = Enum.TextXAlignment.Left lbl.TextColor3 = Color3.fromRGB(220,220,220) lbl.Parent = logsList task.defer(function() local layout = logsList:FindFirstChildOfClass("UIListLayout") if layout then logsScroll.CanvasSize = UDim2.new(0,0,0,layout.AbsoluteContentSize.Y + 4) logsScroll.CanvasPosition = Vector2.new(0, layout.AbsoluteContentSize.Y + 4) end end) end end -- ===== minimize / restore ===== local savedMainPosition btnMin.MouseButton1Click:Connect(function() savedMainPosition = main.Position fadeOut(main, UI_FADE_TIME) alwaysVisibleStatus.Visible = false minimizedBtn.Visible = true end) minimizedBtn.MouseButton1Click:Connect(function() minimizedBtn.Visible = false alwaysVisibleStatus.Visible = true main.Position = savedMainPosition or main.Position fadeIn(main, UI_FADE_TIME) end) -- ===== close confirmation ===== btnClose.MouseButton1Click:Connect(function() confirmationFrame.Visible = true end) btnNo.MouseButton1Click:Connect(function() confirmationFrame.Visible = false end) btnYes.MouseButton1Click:Connect(function() confirmationFrame.Visible = false -- disable features state.keyBypass = false state.esp = false state.killAura = false state.silentAim = false state.killLoopId = state.killLoopId + 1 if RayCastModule and oldRayIgnore then pcall(function() RayCastModule.RayIgnoreNonCollideWithIgnoreList = oldRayIgnore end) end if screenGui then screenGui:Destroy() end end) -- layout: left controls + right logs local left = Instance.new("Frame", main) left.Size = UDim2.new(0.45, -12, 1, -52) left.Position = UDim2.new(0, 8, 0, 44) left.BackgroundTransparency = 1 local right = Instance.new("Frame", main) right.Size = UDim2.new(0.55, -12, 1, -52) right.Position = UDim2.new(0.45, 6, 0, 44) right.BackgroundTransparency = 0.02 right.BackgroundColor3 = Color3.fromRGB(14,14,16) right.BorderSizePixel = 0 right.ClipsDescendants = true local leftLayout = Instance.new("UIListLayout", left) leftLayout.SortOrder = Enum.SortOrder.LayoutOrder leftLayout.Padding = UDim.new(0,8) local function newRow(parent, height) height = height or 32 local f = Instance.new("Frame") f.Size = UDim2.new(1,0,0,height) f.BackgroundTransparency = 1 f.Parent = parent return f end local function createToggle(parent, labelText, default, callback) local row = newRow(parent,34) local lbl = Instance.new("TextLabel", row) lbl.Size = UDim2.new(0.6,0,1,0) lbl.BackgroundTransparency = 1 lbl.Text = labelText lbl.Font = Enum.Font.SourceSans lbl.TextSize = 14 lbl.TextColor3 = Color3.fromRGB(230,230,230) lbl.TextXAlignment = Enum.TextXAlignment.Left local btn = Instance.new("TextButton", row) btn.Size = UDim2.new(0,64,0,26) btn.Position = UDim2.new(1,-72,0,4) btn.Text = default and "ON" or "OFF" btn.Font = Enum.Font.SourceSansBold btn.TextSize = 13 btn.BorderSizePixel = 0 btn.BackgroundColor3 = default and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70) btn.TextColor3 = Color3.fromRGB(255,255,255) local st = default btn.MouseButton1Click:Connect(function() st = not st btn.Text = st and "ON" or "OFF" btn.BackgroundColor3 = st and Color3.fromRGB(128,0,128) or Color3.fromRGB(70,70,70) callback(st) end) return row, btn end local function createSlider(parent, name, min, max, default, callback) local row = newRow(parent,36) local lbl = Instance.new("TextLabel", row) lbl.Size = UDim2.new(0.58,0,1,0) lbl.BackgroundTransparency = 1 lbl.Text = name .. ": " .. tostring(default) lbl.Font = Enum.Font.SourceSans lbl.TextSize = 14 lbl.TextColor3 = Color3.fromRGB(220,220,220) lbl.TextXAlignment = Enum.TextXAlignment.Left local slider = Instance.new("Frame", row) slider.Size = UDim2.new(0.38,0,0.45,0) slider.Position = UDim2.new(0.6,0,0.275,0) slider.BackgroundColor3 = Color3.fromRGB(60,60,60) slider.BorderSizePixel = 0 slider.ClipsDescendants = true local fill = Instance.new("Frame", slider) fill.Size = UDim2.new((default-min)/(max-min),0,1,0) fill.BackgroundColor3 = Color3.fromRGB(128,0,128) fill.BorderSizePixel = 0 local dragging = false local conn local function updateFromPos(pos) local x = math.clamp(pos.X - slider.AbsolutePosition.X, 0, slider.AbsoluteSize.X) local pct = x / slider.AbsoluteSize.X local value = math.floor(min + pct * (max - min)) fill.Size = UDim2.new(pct,0,1,0) lbl.Text = name .. ": " .. tostring(value) callback(value) end slider.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then dragging = true main.Draggable = false conn = UserInputService.InputChanged:Connect(function(move) if dragging and (move.UserInputType == Enum.UserInputType.MouseMovement or move.UserInputType == Enum.UserInputType.Touch) then updateFromPos(move.Position) end end) end end) slider.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then dragging = false main.Draggable = true if conn then conn:Disconnect(); conn = nil end end end) return row, slider, fill, lbl end -- ===== left controls ===== -- Keycard toggle createToggle(left, "Keycard Bypass", false, function(v) state.keyBypass = v local ok, plrUtils = pcall(function() return ReplicatedStorage:FindFirstChild("Game") and ReplicatedStorage.Game:FindFirstChild("PlayerUtils") end) if ok and plrUtils then if v then if not rawget(_G, "SmileB_original_hasKey") then pcall(function() rawset(_G, "SmileB_original_hasKey", require(plrUtils).hasKey) end) end pcall(function() require(plrUtils).hasKey = function() return true end end) pushLog("Keycard bypass enabled") else pcall(function() require(plrUtils).hasKey = rawget(_G, "SmileB_original_hasKey") or require(plrUtils).hasKey end) pushLog("Keycard bypass disabled") end else pushLog("Keycard bypass: PlayerUtils not found") end alwaysVisibleStatus.Text = ("Pistol: %s KillAura: %s SilentAim: %s ESP: %s KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF")) end) -- KillAura toggle createToggle(left, "KillAura", false, function(v) state.killAura = v pushLog("KillAura toggled: "..tostring(v)) if v and LocalPlayer.Character then spawn(function() runKillAura(LocalPlayer.Character) end) else state.killLoopId = state.killLoopId + 1 end alwaysVisibleStatus.Text = ("Pistol: %s KillAura: %s SilentAim: %s ESP: %s KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF")) end) -- SilentAim toggle createToggle(left, "Silent Aim", false, function(v) state.silentAim = v pushLog("Silent Aim toggled: "..tostring(v)) updateSilentAimOverride(v) if v then ensurePistol() end alwaysVisibleStatus.Text = ("Pistol: %s KillAura: %s SilentAim: %s ESP: %s KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF")) end) -- Range slider (shared) local _,_,_, killLabel = createSlider(left, "Range (KillAura/Silent)", 100, 5000, DEFAULT_KILL_RANGE, function(v) state.killRange = v killLabel.Text = "Range (KillAura/Silent): "..tostring(v) end) state.killRange = DEFAULT_KILL_RANGE -- ESP toggle createToggle(left, "ESP", false, function(v) state.esp = v pushLog("ESP toggled: "..tostring(v)) if not v then for p,h in pairs(highlightMap) do pcall(function() h:Destroy() end) highlightMap[p] = nil end for p,b in pairs(nameTagMap) do pcall(function() b:Destroy() end) nameTagMap[p] = nil end else for _,pl in pairs(Players:GetPlayers()) do spawn(function() pcall(function() setupESPForPlayer(pl) end) end) end end alwaysVisibleStatus.Text = ("Pistol: %s KillAura: %s SilentAim: %s ESP: %s KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF")) end) -- Grab Items button local grabRow = newRow(left, 34) local grabLbl = Instance.new("TextLabel", grabRow) grabLbl.Size = UDim2.new(0.6,0,1,0) grabLbl.BackgroundTransparency = 1 grabLbl.Text = "Grab Items" grabLbl.Font = Enum.Font.SourceSans grabLbl.TextSize = 14 grabLbl.TextColor3 = Color3.fromRGB(230,230,230) grabLbl.TextXAlignment = Enum.TextXAlignment.Left local grabBtn = Instance.new("TextButton", grabRow) grabBtn.Size = UDim2.new(0,64,0,26) grabBtn.Position = UDim2.new(1,-72,0,4) grabBtn.Text = "Grab" grabBtn.Font = Enum.Font.SourceSansBold grabBtn.TextSize = 13 grabBtn.BorderSizePixel = 0 grabBtn.BackgroundColor3 = Color3.fromRGB(70,70,70) grabBtn.TextColor3 = Color3.fromRGB(255,255,255) -- ===== right logs panel ===== local logsTitle = Instance.new("TextLabel", right) logsTitle.Size = UDim2.new(1,0,0,26) logsTitle.Position = UDim2.new(0,0,0,4) logsTitle.BackgroundTransparency = 1 logsTitle.Text = "Logs (last "..LOG_CAP..")" logsTitle.Font = Enum.Font.SourceSansBold logsTitle.TextSize = 14 logsTitle.TextColor3 = Color3.fromRGB(220,220,220) local clearBtn = Instance.new("TextButton", right) clearBtn.Size = UDim2.new(0,64,0,24) clearBtn.Position = UDim2.new(1,-72,0,4) clearBtn.Text = "Clear" clearBtn.Font = Enum.Font.SourceSans clearBtn.TextSize = 12 clearBtn.BackgroundColor3 = Color3.fromRGB(80,80,80) clearBtn.TextColor3 = Color3.fromRGB(240,240,240) clearBtn.BorderSizePixel = 0 logsScroll = Instance.new("ScrollingFrame", right) logsScroll.Size = UDim2.new(1,-8,1,-44) logsScroll.Position = UDim2.new(0,4,0,36) logsScroll.BackgroundTransparency = 1 logsScroll.ScrollBarThickness = 8 logsList = Instance.new("Frame", logsScroll) logsList.Size = UDim2.new(1,0,1,0) logsList.BackgroundTransparency = 1 logsList.Name = "LogsList" local logsLayout = Instance.new("UIListLayout", logsList) logsLayout.SortOrder = Enum.SortOrder.LayoutOrder logsLayout.Padding = UDim.new(0,4) clearBtn.MouseButton1Click:Connect(function() for _,c in ipairs(logsList:GetChildren()) do if c:IsA("TextLabel") then c:Destroy() end end logs = {} pushLog("Logs cleared") end) -- ===== ESP ===== local highlightMap = {} local nameTagMap = {} local function teamColorForPlayer(p) if not p then return Color3.fromRGB(200,200,200) end local t = tostring(p.Team) if t == "Police" then return Color3.fromRGB(0,122,255) end if t == "Criminal" then return Color3.fromRGB(255,40,40) end return p.TeamColor and p.TeamColor.Color or Color3.fromRGB(200,200,200) end local function makeNameTagFor(p) if not p.Character then return nil end local head = p.Character:FindFirstChild("Head") if not head then return nil end local bg = Instance.new("BillboardGui") bg.Name = "SmileB_NameTag" bg.Size = UDim2.new(0,160,0,28) bg.StudsOffset = Vector3.new(0,2.2,0) bg.AlwaysOnTop = true bg.Adornee = head local txt = Instance.new("TextLabel", bg) txt.Size = UDim2.new(1,0,1,0) txt.BackgroundTransparency = 1 txt.Font = Enum.Font.SourceSansBold txt.TextScaled = true txt.Text = p.Name txt.TextColor3 = teamColorForPlayer(p) txt.TextStrokeTransparency = 0 return bg, txt end function setupESPForPlayer(p) if not state.esp or not p or not p.Character then return end pcall(function() if highlightMap[p] and highlightMap[p].Parent then highlightMap[p]:Destroy() end local existing = p.Character:FindFirstChild("SmileB_Highlight") if existing then existing:Destroy() end local hl = Instance.new("Highlight") hl.Name = "SmileB_Highlight" hl.Adornee = p.Character hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop hl.Parent = p.Character highlightMap[p] = hl hl.FillColor = teamColorForPlayer(p) end) pcall(function() if nameTagMap[p] and nameTagMap[p].Parent then nameTagMap[p]:Destroy() end local bg, txt = makeNameTagFor(p) if bg then bg.Parent = p.Character; nameTagMap[p] = bg end end) end function cleanupESPForPlayer(p) if highlightMap[p] then pcall(function() highlightMap[p]:Destroy() end) highlightMap[p] = nil end if nameTagMap[p] then pcall(function() nameTagMap[p]:Destroy() end) nameTagMap[p] = nil end end function updateESPColorFor(p) if not state.esp then return end if highlightMap[p] and highlightMap[p].Parent then highlightMap[p].FillColor = teamColorForPlayer(p) end if nameTagMap[p] and nameTagMap[p].Parent then local lbl = nameTagMap[p]:FindFirstChildWhichIsA("TextLabel") if lbl then lbl.TextColor3 = teamColorForPlayer(p) end end end Players.PlayerAdded:Connect(function(pl) pl.CharacterAdded:Connect(function() if state.esp then setupESPForPlayer(pl) end end) pl:GetPropertyChangedSignal("TeamColor"):Connect(function() updateESPColorFor(pl) end) end) Players.PlayerRemoving:Connect(function(pl) cleanupESPForPlayer(pl) end) for _,pl in ipairs(Players:GetPlayers()) do pl.CharacterAdded:Connect(function() if state.esp then setupESPForPlayer(pl) end end) pl:GetPropertyChangedSignal("TeamColor"):Connect(function() updateESPColorFor(pl) end) end -- realtime update loop for ESP spawn(function() while main and main.Parent do if state.esp then local myChar = LocalPlayer.Character local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart") for _,pl in ipairs(Players:GetPlayers()) do if pl ~= LocalPlayer then if pl.Character then if not highlightMap[pl] then pcall(function() setupESPForPlayer(pl) end) end pcall(function() updateESPColorFor(pl) end) if nameTagMap[pl] and nameTagMap[pl].Parent then local theirRoot = pl.Character:FindFirstChild("HumanoidRootPart") local dist = myRoot and theirRoot and math.floor((myRoot.Position - theirRoot.Position).Magnitude) or "?" local lbl = nameTagMap[pl]:FindFirstChildWhichIsA("TextLabel") if lbl then lbl.Text = pl.Name .. " (" .. tostring(dist) .. " studs)" end end else pcall(function() cleanupESPForPlayer(pl) end) end end end end task.wait(ESP_UPDATE_INTERVAL) end end) -- periodic full reload for ESP (every 10s) spawn(function() while main and main.Parent do if state.esp then for _,pl in ipairs(Players:GetPlayers()) do pcall(function() cleanupESPForPlayer(pl) setupESPForPlayer(pl) end) end end task.wait(ESP_FULL_RELOAD_INTERVAL) end end) -- ===== pistol acquisition (reused) ===== local function tryClickGiversOnce() if not Workspace:FindFirstChild("Givers") then return false end for _,g in ipairs(Workspace.Givers:GetChildren()) do if not g or not g.Parent then continue end local cd = g:FindFirstChildWhichIsA("ClickDetector") if cd then pcall(function() fireclickdetector(cd) end) task.wait(0.04) if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then return true end end end return false end -- attempt to pickup dropped items on ground by simulating touch local function tryPickupDroppedOnce() local char = LocalPlayer.Character local hrp = char and char:FindFirstChild("HumanoidRootPart") if not hrp then return false end local found = false for _,obj in ipairs(Workspace:GetDescendants()) do if obj:IsA("BasePart") and obj.Parent and obj.Parent:IsA("Model") then local name = tostring(obj.Name):lower() -- list of keywords commonly used for dropped items; extend if needed if string.find(name, "pistol") or string.find(name, "gun") or string.find(name, "rifle") or string.find(name, "shotgun") or string.find(name, "ammo") or string.find(name, "cash") or string.find(name, "money") or string.find(name, "bag") or string.find(name, "drop") then pcall(function() firetouchinterest(obj, hrp, 0) task.wait(0.03) firetouchinterest(obj, hrp, 1) task.wait(0.05) end) found = true -- if we got an item into Folder, return early if LocalPlayer:FindFirstChild("Folder") and #LocalPlayer.Folder:GetChildren() > 0 then return true end end end end return found end local function ensurePistol() if state.tryingToGetPistol or state.hasPistol then return end state.tryingToGetPistol = true pushLog("Pistol acquisition: scanning Givers...") spawn(function() local attempts = 0 while not state.hasPistol and attempts < GIVEITEM_MAX_ATTEMPTS do pcall(tryClickGiversOnce) attempts = attempts + 1 if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then state.hasPistol = true pushLog("Pistol obtained after "..tostring(attempts).." attempts") break end task.wait(GIVEITEM_ATTEMPT_DELAY) end if not state.hasPistol then pushLog("Pistol acquisition: failed after attempts") end state.tryingToGetPistol = false alwaysVisibleStatus.Text = ("Pistol: %s KillAura: %s SilentAim: %s ESP: %s KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF")) end) end -- Item grabber that tries to click Givers and touch-pickup dropped items aggressively local function grabAllItems() if state.tryingToGetPistol then pushLog("Already attempting to get items") return end state.tryingToGetPistol = true pushLog("Item grabber: starting aggressive gather...") spawn(function() local startCount = LocalPlayer:FindFirstChild("Folder") and #LocalPlayer.Folder:GetChildren() or 0 local attempts = 0 while attempts < GIVEITEM_MAX_ATTEMPTS do -- try click givers first pcall(tryClickGiversOnce) -- then try pickup dropped items (touch) pcall(tryPickupDroppedOnce) attempts = attempts + 1 local nowCount = LocalPlayer:FindFirstChild("Folder") and #LocalPlayer.Folder:GetChildren() or 0 if nowCount > startCount then pushLog("Item grabber: new items obtained after "..tostring(attempts).." attempts") break end task.wait(GIVEITEM_ATTEMPT_DELAY) end if attempts >= GIVEITEM_MAX_ATTEMPTS then pushLog("Item grabber: finished with no new items") end state.tryingToGetPistol = false end) end grabBtn.MouseButton1Click:Connect(function() grabAllItems() end) -- pistol loss watcher and general folder checker spawn(function() local folder = LocalPlayer:FindFirstChild("Folder", 10) if folder then folder.ChildRemoved:Connect(function(child) if child.Name == "Pistol" then state.hasPistol = false pushLog("Pistol lost from inventory") alwaysVisibleStatus.Text = ("Pistol: %s KillAura: %s SilentAim: %s ESP: %s KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF")) if state.killAura or state.silentAim then ensurePistol() end end end) end while true do if state.hasPistol and not (LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol")) then state.hasPistol = false pushLog("Pistol no longer detected") alwaysVisibleStatus.Text = ("Pistol: %s KillAura: %s SilentAim: %s ESP: %s KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF")) if state.killAura or state.silentAim then ensurePistol() end end task.wait(PISTOL_CHECK_INTERVAL) end end) -- ===== team/enemy helper ===== local function teamString(pl) if not pl then return "" end return tostring(pl.Team) end local function isEnemyTeam(myTeam, theirTeam) -- Police attack Criminal only. Police do not attack Prisoner. -- Criminal and Prisoner attack Police only. if myTeam == "Police" then return theirTeam == "Criminal" end if myTeam == "Criminal" or myTeam == "Prisoner" then return theirTeam == "Police" end -- fallback: treat different teams as enemies return myTeam ~= theirTeam end -- ===== target selection (uses priority window based on lastDamagePosition) ===== local function getNearestEnemy(maxRange) maxRange = maxRange or DEFAULT_KILL_RANGE local nearestDistance = maxRange local nearestEnemy = nil local myTeam = teamString(LocalPlayer) local priorityActive = (tick() - lastDamageTime) < DAMAGE_PRIORITY_WINDOW and lastDamagePosition local myPos = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position) or Vector3.new() for _,v in pairs(Players:GetPlayers()) do if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 then local theirTeam = teamString(v) if isEnemyTeam(myTeam, theirTeam) then local distToMyPos = (v.Character.HumanoidRootPart.Position - myPos).Magnitude local dist = distToMyPos if priorityActive then -- prefer enemies closer to the lastDamagePosition local pdist = (v.Character.HumanoidRootPart.Position - lastDamagePosition).Magnitude dist = pdist -- but still bound by maxRange from player if distToMyPos > maxRange then -- out of effective range for engagement continue end end if dist < nearestDistance then nearestDistance = dist nearestEnemy = v end end end end return nearestEnemy end -- ===== damage watcher (records lastDamagePosition when damaged) ===== spawn(function() while main and main.Parent do local char = LocalPlayer.Character if char and char:FindFirstChild("Humanoid") then local hum = char.Humanoid if lastHealth == nil then lastHealth = hum.Health end if hum.Health < lastHealth then lastDamageTime = tick() local hrp = char:FindFirstChild("HumanoidRootPart") if hrp then lastDamagePosition = hrp.Position end pushLog("Local damage detected; prioritization active for "..tostring(DAMAGE_PRIORITY_WINDOW).."s") end lastHealth = hum.Health end task.wait(0.25) end end) -- ===== silent aim override (now mirrors kill aura logic and respects teams) ===== function updateSilentAimOverride(enabled) if not RayCastModule or not oldRayIgnore then return end if enabled then RayCastModule.RayIgnoreNonCollideWithIgnoreList = function(...) local nearestEnemy = getNearestEnemy(state.killRange or DEFAULT_KILL_RANGE) local arg = {oldRayIgnore(...) } if (tostring(getfenv(2).script) == "BulletEmitter" or tostring(getfenv(2).script) == "Taser") and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") then arg[1] = nearestEnemy.Character.HumanoidRootPart arg[2] = nearestEnemy.Character.HumanoidRootPart.Position end return unpack(arg) end ensurePistol() else pcall(function() RayCastModule.RayIgnoreNonCollideWithIgnoreList = oldRayIgnore end) end end -- ===== kill aura loop ===== function runKillAura(character) if not character then return end state.killLoopId = state.killLoopId + 1 local myLoopId = state.killLoopId pushLog("KillAura loop started (id "..tostring(myLoopId)..")") if not state.hasPistol then ensurePistol() end spawn(function() while true do if state.killLoopId ~= myLoopId then break end if not state.killAura then break end if not character or not character.Parent then break end local hrp = character:FindFirstChild("HumanoidRootPart") if not hrp then break end -- if not armed, try to acquire pistol and wait if not state.hasPistol then if not state.tryingToGetPistol then ensurePistol() end task.wait(KILLAURA_TICK) else local nearestEnemy = getNearestEnemy(state.killRange or DEFAULT_KILL_RANGE) if nearestEnemy then -- apply temporary raycast override to aim at target pcall(function() if RayCastModule and oldRayIgnore then RayCastModule.RayIgnoreNonCollideWithIgnoreList = function(...) local arg = {oldRayIgnore(...) } if (tostring(getfenv(2).script) == "BulletEmitter" or tostring(getfenv(2).script) == "Taser") and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") and nearestEnemy.Character:FindFirstChild("Humanoid") and (nearestEnemy.Character.HumanoidRootPart.Position - hrp.Position).Magnitude < (state.killRange or DEFAULT_KILL_RANGE) and nearestEnemy.Character.Humanoid.Health > 0 then arg[1] = nearestEnemy.Character.HumanoidRootPart arg[2] = nearestEnemy.Character.HumanoidRootPart.Position end return unpack(arg) end end end) -- attempt to equip and shoot if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then local shotCount = 0 pcall(function() LocalPlayer.Folder.Pistol.InventoryEquipRemote:FireServer(true) end) task.wait(EQUIP_WAIT_TIME) while state.killAura and nearestEnemy and nearestEnemy.Character and nearestEnemy.Character:FindFirstChild("HumanoidRootPart") and nearestEnemy.Character:FindFirstChild("Humanoid") and nearestEnemy.Character.Humanoid.Health > 0 and (nearestEnemy.Character.HumanoidRootPart.Position - hrp.Position).Magnitude < (state.killRange or DEFAULT_KILL_RANGE) do local currentGun = nil pcall(function() currentGun = require(ReplicatedStorage.Game.ItemSystem.ItemSystem).GetLocalEquipped() end) if currentGun then pcall(function() require(ReplicatedStorage.Game.Item.Gun)._attemptShoot(currentGun) end) shotCount = shotCount + 1 if shotCount % 50 == 0 then pushLog("Fired " .. tostring(shotCount) .. " shots at " .. nearestEnemy.Name) end end task.wait(FIRE_DELAY) end pcall(function() LocalPlayer.Folder.Pistol.InventoryEquipRemote:FireServer(false) end) end -- restore raycast override pcall(function() if RayCastModule and oldRayIgnore then RayCastModule.RayIgnoreNonCollideWithIgnoreList = oldRayIgnore end end) end task.wait(KILLAURA_TICK) end end pushLog("KillAura loop stopped (id "..tostring(myLoopId)..")") alwaysVisibleStatus.Text = ("Pistol: %s KillAura: %s SilentAim: %s ESP: %s KeyBypass: %s"):format((state.hasPistol and "Yes" or "No"), (state.killAura and "ON" or "OFF"), (state.silentAim and "ON" or "OFF"), (state.esp and "ON" or "OFF"), (state.keyBypass and "ON" or "OFF")) end) end -- ===== respawn handling ===== LocalPlayer.CharacterAdded:Connect(function(char) pushLog("Character respawned") lastHealth = char:FindFirstChild("Humanoid") and char.Humanoid.Health or nil if state.killAura then spawn(function() runKillAura(char) end) end if state.silentAim then updateSilentAimOverride(true) end if state.keyBypass then pcall(function() local plrUtils = ReplicatedStorage:FindFirstChild("Game") and ReplicatedStorage.Game:FindFirstChild("PlayerUtils") if plrUtils then require(plrUtils).hasKey = function() return true end end end) end if state.esp then for _,pl in ipairs(Players:GetPlayers()) do spawn(function() pcall(function() setupESPForPlayer(pl) end) end) end end end) -- initial check for pistol if LocalPlayer:FindFirstChild("Folder") and LocalPlayer.Folder:FindFirstChild("Pistol") then state.hasPistol = true pushLog("Pistol present on load") end pushLog("Smile B UI loaded and running") _G.SmileB = { state = state, pushLog = pushLog, ensurePistol = ensurePistol } -- done
